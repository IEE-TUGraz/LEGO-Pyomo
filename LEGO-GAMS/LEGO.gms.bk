$Title Low-carbon Electricity Generation Optimization (LEGO) model
*Test
$OnText

Developed by

   Sonja Wogrin
   wogrin@tugraz.at
   Diego Alejandro Tejada Arango
   dtejada@comillas.edu
   
Contributors
   Thomas Klatzer
   thomas.klatzer@tugraz.at
   Robert Gaugl
   robert.gaugl@tugraz.at

Version: 2021-06
Integrated version including: DSM + TEP (SOCP) + H2 (Basic)
Code Folding works with GAMS Studio version 32 or newer
(Fold all: Alt+O; Unfold all: Shift+Alt+O)

$OffText

*-------------------------------------------------------------------------------
*                                 Options
*-------------------------------------------------------------------------------
* definition of symbol for comments at the end of the line
$EOLCOM //

$onFold // Options -------------------------------------------------------------

$OnEmpty OnMulti OffListing

* Check if GAMS version fulfills minimum requirements (checking mm.n as mmn, i.e. 46.1 -> 461)
$if not GamsVersion 461 $abort GAMS version 46.1 or newer is required to run this model, current version is %system.GamsRelease%

* Check if scenario folder has been defined
$if not set scenarioFolder $abort Scenario folder not defined. Missing: --scenarioFolder=[Path to scenario folder]
$log Scenario folder defined: %scenarioFolder%

* Check if some variable hasn't been used yet (there shouldn't be any)
$setDDList

* Default values for command parameters
$if not set BatchUpdate $set BatchUpdate "0"
$if not set RelaxedMIP  $set RelaxedMIP  "0"
$if not set EnableSOCP  $set EnableSOCP  "0"
$if not set RegretCalc  $set RegretCalc  "0"

* optimizer definition
option   lp   = gurobi ;
option  mip   = gurobi ;
option rmip   = gurobi ;
option rmiqcp = gurobi ;
option  miqcp = gurobi ;

* general options
option optcr    =   1e-2 ;   // tolerance to solve MIP until IntGap < OptcR
option reslim   =  43200 ;   // maximum run time [sec]
option threads  =     -1 ;   // number of cores
option solprint =    on  ;   // print the final solution in the .lst file
option limrow   =    100 ;   // maximum number of equations in the .lst file
option limcol   =    100 ;   // maximum number of variables in the .lst file
option savepoint=      0 ;   // save into a gdx file solution (0=no save, 1=only the last one, 2=for each solve)

* profile options
option profile=1, profileTol = 0.01 ;

$offFold


*-------------------------------------------------------------------------------
*                                Definitions
*-------------------------------------------------------------------------------
$onFold // Sets ----------------------------------------------------------------

sets
* sets to preserve chronology
   p                     "periods                                            "
 
* sets for representative periods model 
   rp                    "                           representative periods  "
   k                     "periods inside a           representative period   " /k0001/
   hindex(p<,rp<,k<)     "relation among periods and representative periods  "
   rpk   (   rp ,k )     "active                     representative periods  "
   
   
* set for zones   
   z                     "zones                                              "
   za(z)                 "zones with network                                 "
 
* sets for thermal units, hydro units, renewables and reservoirs 
   g                     "generating unit                                    "
   t    (g    )          "thermal    unit including biomass                  "
   s    (g    )          "storage    unit                                    "
   ror  (g    )          "run of river unit                                  "
   r    (g    )          "variable renewable energy sources                  "
   b    (g    )          "biomass    unit                                    "
   solar(g    )          "solar      unit                                    "
   wind (g    )          "wind       unit                                    "
   hydro(g    )          "hydro      unit                                    "
   gas  (g    )          "gas        unit                                    "
   bess (g    )          "battery    unit                                    "
   v    (g    )          "virtual  generators                                "
   ga   (g    )          "active   generators                                "
   facts(g    )          "FACTS for reactive power sources                   "
   tec                   "generation technologies                            "
   gz   (g,z  )          "relation among generation and zones                "
 
* sets for transmission network 
   i                     "node i                                             "
   c                     "circuit c                                          "
   is    (i<     )       "slack bus                                          "
   iact  (i      )       "active nodes for balance constraints               "
   la    (i ,i ,c)       "all       transmission lines                       "
   le    (i ,i ,c)       "existing  transmission lines                       "
   lc    (i ,i ,c)       "candidate transmission lines                       "
   isLine(i ,i   )       "transmission line connecting nodes i,j             "
   isLc  (i ,i   )       "transmission candidate line connecting nodes i,j   "
   isLe  (i ,i   )       "transmission existing  line connecting nodes i,j   "
   gi    (g<,i<  )       "generator g connected to node i                    "
   iz    (i<,z<  )       "nodes i within zone z                              "
   lbz   (i ,i ,c)       "lines between  zones                               "
   inws  (i      )       "nodes not within system (import/export countries)  "
   iws   (i      )       "nodes     within system                            "   

* sets for import/export      
   rpkimp    (rp,k,i)    "active import representative periods               "
   rpkexp    (rp,k,i)    "active export representative periods               "
   rpknimpexp(rp,k,i)    "active not import and export representative periods"
   
* sets for segments in the cycle aging cost function
   a                     "Segments in the cycle aging cost   function        "
   cdsf      (g  )       "Storage with a  cycle depth stress function        "
   pCDSF_phi (g,a)       "Cycle depth stress function - phi                  " 
   pCDSF_cost(g,a)       "Marginal aging cost of cycle depth segment a       " 

* sets for RoCoF
   m                     "Blocks for linearizing integer investment variable "

* sets for demand-side management
   sec                   "Sectors for DSM shifting                           "
   seg                   "Segments for price-responsive DSM                  "
   dsm (rp,k,k,sec)      "periods within rp that are related in DSM shift    "

* sets for hydrogen
   h2sec                 "Sectors of hydrogen demand                         "
   h2tec                 "Hydrogen generating technologies                   "
   h2i                   "Node of hydrogen pipeline network                  "
   h2u                   "Hydrogen units                                     "
   h2g     (h2u<       ) "Subset of hydrogen generating units                "
   h2f     (h2u<       ) "Subset of hydrogen fuel cell unis                  "
   h2s     (h2u<       ) "Subset of hydrogen storage units                   "
   h2gh2i  (h2u<,h2i<  ) "Unit h2u connected to node h2i                     "
   h2gi    (h2u<,  i<  ) "Unit h2u connected to bus i                        "
   h2line  (h2i ,h2i   ) "Node of hydrogen pipeline network                  "
   h2uh2tec(h2u<,h2tec<) "relation among H2 units and technologies           "
   
* sets for NTCs
   NTCe    (z,z        ) "NTC connecting zones                               "
;
alias (i,j), (t,tt), (rp,rpp), (k,kk), (p,pp), (r,rr), (v,vv), (k,kk), (c,cc), (h2i,h2j), (z,y)
;
$offFold

$onFold // Parameters ----------------------------------------------------------

parameters
* general parameters
   pOutput                   "level of output detail                 [        ]" / 1     /
   pENSCost                  "energy non-served cost                 [M€/GWh  ]" / 1e4   /
   pLOLCost                  "line overload cost                     [M€/GWh  ]" / 1e2   /
   p2ndResUpCost             "cost factor of up   2nd reserve        [p.u.    ]" / 0.2   /
   p2ndResDwCost             "cost factor of down 2nd reserve        [p.u.    ]" / 0.2   /
   p2ndResUp                 "     needs  of up   2nd reserve        [%       ]" / 0.02  /
   p2ndResDw                 "     needs  of down 2nd reserve        [%       ]" / 0.02  /
   pMinInertia               "minimum required inertia               [s       ]" / 0     /
   pMinGreenProd             "minimum green production               [p.u.    ]" / 0     /
   pMaxLineLoad              "soft limit for maximum power line load [p.u.    ]" / 1.00  /
   pBigM_Flow                "big-M constant                                   " / 1e3   /
   pBigM_SOCP                "big-M constant                                   " / 1e3   /
   pMinFirmCap               "minimum firm capacity                  [p.u.    ]" / 0     /
   pkWh_Mcal                 "conversion factor kWh and Mcal         [kWh/Mcal]" / 1.162 /
   pEnablePower              "Enables Power (TODO: Not used for now)           " / 1     / 
   pEnableGas                "Enables Gas   (TODO: Not used for now)           " / 1     /
   pEnableHeat               "Enables Heat  (TODO: Not used for now)           " / 1     /
   pMaxAngleDCOPF            "Maximum angle for vTheta in DCOPF"

* generation units parameters
   pEFOR             (g)     "EFOR                                   [p.u.    ]"
   pExisUnits        (g)     "existing thermal units                 [0-N     ]"
   pMaxProd          (g)     "maximum output                         [   GW   ]"
   pMinProd          (g)     "minimum output                         [   GW   ]"
   pRampUp           (g)     "ramp up limit                          [   GW   ]"
   pRampDw           (g)     "ramp dw limit                          [   GW   ]"
   pMaxGenQ          (g)     "maximum reactive power output          [Gvar    ]"
   pMinGenQ          (g)     "minimum reactive power output          [Gvar    ]"
   pMaxCons          (g)     "maximum consumption                    [   GW   ]"
   pInertiaConst     (g)     "inertia constant H                     [s       ]"
   pSlopeVarCost     (g)     "slope     variable cost                [M€/GWh  ]"
   pInterVarCost     (g)     "intercept variable cost                [M€/  h  ]"
   pStartupCost      (g)     "startup            cost                [M€      ]"
   pSlopeVarFuelCons (g)     "slope variable fuel consumption        [p.u.    ]"
   pInterVarCons     (g)     "inter variable consumption             [GWh/h   ]"
   pStartupCons      (g)     "startup            consumption         [GWh     ]"
   pMinReserve       (g)     "minimum reserve                        [p.u.    ]"
   pIniReserve       (g)     "initial reserve                        [GWh     ]"
   pProdFacRes       (g)     "reservoir production function          [GWh/km3 ]"
   pProdFunct        (g)     "hydrogen  production function          [GWh/km3 ]"
   pDisEffic         (g)     "discharge  efficiency                  [p.u.    ]"
   pChEffic          (g)     "   charge  efficiency                  [p.u.    ]"
   pIniUC            (g)     "initial commitment                     [0-1     ]"
   pIsHydro          (g)     "hydro unit identifier                  [0-1     ]"
   pEnabInv          (g)     "enable investment                      [0-1     ]"
   pInvestCost       (g)     "investment cost                        [M€/GW/y ]"
   pOMVarCost        (g)     "O&M variable cost                      [M€/GWh  ]"
   pMaxInvest        (g)     "maximum investment capacity            [   GW   ]"
   pE2PRatio         (g)     "energy to power ratio                  [h       ]"
   pFirmCapCoef      (g)     "firm capacity contribution             [p.u.    ]"
   
* import/export paramters
   pMaxImport  (rp,k,i)      "import into import-export-countries    [   GW   ]"
   pMaxExport  (rp,k,i)      "export into import-export-countries    [   GW   ]"
   pPriceImpExp(rp,k,i)      "price of import export                 [M€/GWh  ]"

* zonal demand and generation parameters
   pPumpDemand(z)            "pump            demand     per zone    [   GWh  ]"
   pMinSolar  (z)            "minimum PV      generation per zone    [   GWh  ]"
   pMinWind   (z)            "minimum wind    generation per zone    [   GWh  ]" 
   pMinBio    (z)            "minimum biomass generation per zone    [   GWh  ]"
   pMinWater  (z)            "minimum water   generation per zone    [   GWh  ]"
   pMaxGas    (z)            "maximum gas     generation per zone    [   GWh  ]"
   
* NTC parameters
   pNTC       (z,z)         "maximum NTC between zones               [   GWh  ]"
   pNTCCost                 "Kosten für Übertragung                  [M€/GWh  ]" / 0.1e-6 /

* parameters for modeling demand-side management
   pMaxUpDSM    (rp,k,i,sec) "Bound on demand-side man. up           [   GW   ]"
   pMaxDnDSM    (rp,k,i,sec) "Bound on demand-side man. down         [   GW   ]"
   pDSMShiftCost(rp,k,i)     "Cost of shifting DSM                   [M€/GWh  ]"
   pDSMShedCost (seg   )     "Cost of price-responsive DSM           [M€/GWh  ]"
   pDSMShedRatio(seg   )     "Percentage of shedding DSM             [p.u.    ]"
   pDSMDelayTime(sec,rp)     "Delay time for DSM shifting            [h       ]"

* parameters for cycle aging cost of batteries
   pReplaceCost (  g)        "Battery cell replacement cost          [M€/GWh  ]"
   pShelfLife   (  g)        "Battery shelf life                     [years   ]"
   pCDSF_alpha  (  g)        "Cycle Depth Stress Function - alpha              "
   pCDSF_beta   (  g)        "Cycle Depth Stress Function - beta               "
   pCDSF_delta  (p,g)        "Cycle Depth Stress Function - delta              "

* parameters for inertia modeling using RoCoF
   pBaseFreq                 "Base frequency                         [Hz      ]" / 50  /
   pMaxRoCoF                 "Maximum permissible RoCoF              [Hz/s    ]" / 2   /
   pUBLin                    "Upper bound needed for linearization             " / 1e3 /
   pDeltaP     (rp,k      )  "Size of power outage in time rp,k      [p.u.    ]"

* representative periods parameters
   pDemandP    (rp ,k ,i  )  "hourly active   demand per node        [   GW   ]"
   pDemandQ    (rp ,k ,i  )  "hourly reactive demand per node        [   GW   ]"
   pPeakDemand               "active peak demand                     [   GW   ]"
   pInflows    (rp ,k ,g  )  "inflows for hydro storage              [   GWh  ]"
   pResProfile (rp ,k ,i,g)  "maximum renewable production           [   GW   ]"
   pWeight_rp  (rp<       )  "representatives periods weight         [     h  ]"
   pWeight_k   (    k<    )  "hourly weight for each rp              [     h  ]"
   pMovWindow                "Moving window for inter-period         [     h  ]"

* bus parameters
   pBusBaseV   (i)           "Base            voltaje at bus i       [kV      ]"
   pBusMaxV    (i)           "maximum         voltage at bus i       [p.u.    ]"
   pBusMinV    (i)           "minimum         voltage at bus i       [p.u.    ]"
   pBus_pf     (i)           "power factor            at bus i       [p.u.    ]"
   pBusB       (i)           "Suceptance  B connected at bus i       [p.u.    ]"
   pBusG       (i)           "Conductance G connected at bus i       [p.u.    ]"
   pRatioDemQP (i)           "tan(arccos(pf)) = Q/P   at bus i       [p.u.    ]"

* network parameters
   pMaxAngleDiff             "maximum voltage angle difference       [rad     ]"
   pSlackVoltage             "slack bus reference voltage            [p.u.    ]"
   pSBase                    "base power                             [MVA     ]"
   pYBUS       (i,i    )     "susceptance matrix                     [p.u.    ]"
   pYBUSInv    (i,i    )     "susceptance matrix inverse             [p.u.    ]"
   pPmax       (i,i,c  )     "maximum Active   Power Transfer        [GW      ]"
   pQmax       (i,i,c  )     "maximum Reactive Power Transfer        [GWvar   ]"
   pISF        (i,i,c,i)     "injection Shift Factors                [p.u.    ]"
   pXline      (i,i,c  )     "reactance  X of line                   [p.u.    ]"
   pRline      (i,i,c  )     "resistance R of line                   [p.u.    ]"
   pZline      (i,i,c  )     "line Impedance   Z                     [p.u.    ]"
   pBline      (i,i,c  )     "line Suceptance  B                     [p.u.    ]"
   pGline      (i,i,c  )     "line Conductance G                     [p.u.    ]"
   pBcline     (i,i,c  )     "Branch charging susceptance            [p.u.    ]"
   pRatio      (i,i,c  )     "transformer ratio       on             [p.u.    ]"
   pAngle      (i,i,c  )     "transformer angle shift on             [rad     ]"
   pFixedCost  (i,i,c  )     "Annual Fixed Investment Cost           [M€      ]"

* option parameters    
   pEnableRMIP           "solve model as RMIP 0->No, 1->Yes                    " / 0 /
   pEnableTransNet       "option to include transmission network               " / 0 /
   pEnableZP             "option to calculate zonal prices                     " / 0 /
   pEnableMinProdRESTech "option to enable min RES prod. per zone              " / 0 /
   pEnableMaxGas         "option to enable max gas prod. per zone              " / 0 /
   pRegretCalc           "parameter to calculate regret                        " / 0 /
   pEnableSOCP           "Enable SOCP constraints 1->Yes 0->DC                 " / 0 /
   pEnableDummyModel     "Enable Dummy Model to calculate angles               " / 0 /
   pEnableCDSF           "Enable Cycle Depth Stress Function                   " / 0 /
   pEnableRoCoF          "Enable RoCoF constraints and variables               " / 0 /
   pEnableH2             "Enable Hydrogen constraints                          " / 0 /
   pEnableCO2            "Enable CO2      constraints                          " / 0 /
   pRoCoFRegret          "Calcluate RoCoF regret                               " / 0 /
   pEnableDSMPower       "Enable demand-side management                        " / 0 /
   pEnableMaxLineLoad    "Enable to soft-limit the maximum line load           " / 0 /
   pEnableGreenNatBal    "green prod. national bal.->1 or hourly->0            " / 0 /
   pEnableChDisPower     "Enable constr. to avoid simult. charge. and discharg." / 0 /

* hydrogen parameters
   pH2Demand    (rp,k,h2i,h2sec)      "Hydrogen demand per sector                     [t          ]"
   pH2PE        (         h2u  )      "Hydrogen per unit of energy - unit efficiency  [t /GWh     ]"
   pH2OMPercent (         h2u  )      "O&M variable cost percentage of CAPEX          [p.u.       ]"
   pH2OMVarCost (         h2u  )      "O&M variable cost of  hydrogen unit            [M€/GW/y    ]"
   pH2InvestCost(         h2u  )      "Investment   cost for hydrogen unit            [M€/GW/y    ]"
   pH2MaxCons   (         h2u  )      "Technical maximum consumption of hydrogen unit [   GW      ]"
   pH2MaxInvest (         h2u  )      "Maximum investment of hydrogen units           [0-N        ]"
   pH2ExisUnits (         h2u  )      "number of existing    hydrogen units           [0-N        ]"
   pH2_pf       (         h2u  )      "power factor          of hydrogen unit         [p.u.       ]"
   pH2RatioQP   (         h2u  )      "tan(arccos(pf)) = Q/P of hydrogen unit         [p.u.       ]"
   pH2Fmax      (     h2i,h2i  )      "maximum hydrogen flow                          [t          ]"
   pH2NSCost                          "cost of hydrogen not served                    [M€ /t      ]"
   
* CO2 parameters
   pCO2Emis     (g             )      "Specific CO2 emissions per generator           [MtCO2/GW   ]"
   pCO2Cost                           "CO2-cost                                       [M€   /MtCO2]"
   pCO2Budget                         "Total emission budget                          [MtCO2/y    ]"
   pCO2Penalty                        "CO2-penalty for CO2 budget violation           [M€   /MtCO2]"

* parameters for ex-post calculations
   pSummary          (*             ) "Model summary results                                       "
   pCommit           (p,g           ) "commitment of the unit                         [0-1        ]"
   pGenP             (p,g           ) "  active power of the unit                     [   MW      ]"
   pGenQ             (p,g           ) "reactive power of the unit                     [MVar       ]"
   pChrP             (p,g           ) "charging power of the unit                     [   MW      ]"
   pCurtP_k          (rp,k,g        ) "curtailment    of the unit per k               [   MW      ]"
   pCurtP_rp         (rp,  g        ) "curtailment    of the unit per rp              [   MW      ]"   
   pTecProd          (i,*,*         ) "total prod. per technology                     [   GWh     ]"
   pTecProdSum       (*,*           ) "total prod. per technology sum                 [   GWh     ]"
   pTecProdRP        (*,*,*         ) "prod. per technology per rp                    [   GW      ]"
   pTecProdHours     (*,*           ) "prod. per technology per hour                  [   GW      ]"
   pZonalPriceRP     (rp,k,z        ) "zonal price per rp                             [ €/MWh     ]"
   pZonalPrice       (p,z           ) "zonal price                                    [ €/MWh     ]"
   pStIntra          (k,g,rp        ) "intra-period storage level                     [p.u        ]"
   pStLevel          (p,g           ) "storage level during the year                  [p.u        ]"
   pStLvMW           (p,g           ) "storage level moving window                    [   GWh     ]"
   pSRMC             (p,i           ) "short run marginal cost                        [ €/MWh     ]"
   pMC               (      rp,k,i  ) "marginal cost                                  [M€/GW      ]"
   pGenInvest        (*,*           ) "total generation investment                    [   MW      ]"
   pTraInvest        (i,i,c,*       ) "total transmission investment                  [   MW      ]"
   pLineP            (k,i,i,c,rp    ) "  active power flow                            [   MW      ]"
   pLineQ            (k,i,i,c,rp    ) "reactive power flow                            [MVar       ]"
   pLineP_Perc       (k,i,i,c,rp    ) "  active power flow                            [%          ]"
   pSpillag          (p,g           ) "spillage                                       [MWh        ]"
   pVoltage          (k,i,rp        ) "bus voltage                                    [p.u.       ]"
   pTheta            (k,i,rp        ) "Voltage angle of bus i                         [º          ]"
   pBusRes           (k,i,rp,*,*    ) "bus results                                                 "
   pDelVolAng        (rp,k,i,j      ) "Delta of voltage angle                         [rad        ]"
   pResulCDSF        (*,g           ) "Results for storage with CDSF                               "
   pInertDual        (k,rp          ) "Dual variable of inertia constr                [ €/s       ]"
   pRevSpot          (           g  ) "Revenues on spot market                        [M€         ]"
   pRevReserve       (           g  ) "Revenues on reserve market                     [M€         ]"
   pRevRESQuota      (           g  ) "RES payments for quota                         [M€         ]"
   pFirmCapPay       (           g  ) "Payments for firm capacity                     [M€         ]"
   pInvCost          (           g  ) "Investment cost                                [M€         ]"
   pOMCost           (           g  ) "O and M cost                                   [M€         ]"
   pReserveCost      (           g  ) "Cost for reserve provision                     [M€         ]"
   pCostSpot         (           g  ) "Cost for consumption on spot                   [M€         ]"
   pTotalProfits     (           g  ) "Total profits of storage s                     [M€         ]"
   pEconomicResults  (*,         g  ) "Economic Results                               [M€         ]"
   pTotalBESSProfits                  "Total battery tecn profits                     [M€         ]"
   pResultDSM        (i,*,*,rp,k    ) "Results DSM                                    [   GW      ]"
   pActualSysInertia (      k ,rp   ) "actual system inertia                          [s          ]"
   pRoCoF_k          (      rp,k,g  ) "Scaled power gain factor of gen g              [p.u.       ]"
   pRoCoF_SG_M       (      rp,k    ) "Scaled power gain factor of SG                 [p.u.       ]"
   pRoCoF_VI_M       (      rp,k    ) "Scaled power gain factor of VI                 [p.u.       ]"
   pH2price          (h2sec,k,h2i,rp) "Hydrogen price                                 [ €/kg      ]"
   pH2Invest         (h2u,*         ) "Hydrogen units investment                      [   MW      ]"
   pH2NS             (h2sec,k,h2i,rp) "Hydrogen non served                            [   kg      ]"
   pH2Prod           (h2u  ,k,    rp) "Hydrogen unit production                       [   kg      ]"
   pH2Cons           (h2u  ,k,    rp) "Hydrogen unit consumption                      [   MW      ]"
;
$offFold

$onFold // Variables -----------------------------------------------------------

variables
   vTotalVCost              "Total system variable cost                  [M€  ]"
   vDummyOf                 "Dummy objective function variable                 "
   vTheta    (rp,k,i      ) "Voltage angle  of bus i at time rp,k        [rad ]"
   vLineP    (rp,k,i,i,c  ) "Real     power of line ijc                  [GW  ]"
   vLineQ    (rp,k,i,i,c  ) "Reactive power of line ijc                  [Gvar]"
   vGenQ     (rp,k,g      ) "Reactive power gen. of the unit             [Gvar]"
   vSOCP_sij (rp,k,i,i    ) "Auxiliary sij variable for SOCP formulation [p.u.]"
   vH2Flow   (rp,k,h2i,h2i) "Real     power of line ijc                  [GW  ]"
   vAngle    (rp,k,i,i,c  ) "Angle phase shifting transformer            [rad ]"
;
binary    variables
   vRoCoF_AuxI           (   g,m)   "Binary variable used to express vGenInvest as sum of binaries"
   vCommit               (rp,k,g)   "commitment of the unit                         [0-1]         "
   vStartup              (rp,k,g)   "startup    of the unit                         [0-1]         "
   vShutdown             (rp,k,g)   "shutdown   of the unit                         [0-1]         "
   vLineInvest           (i ,j,c)   "transmission line investment                   [0-1]         "
   vSOCP_IndicConnecNodes(i ,i  )   "indicator variable of connection between nodes [0-1]         "
   vChDis                (rp,k,g)   "storage charge or discharge                    [0-1]         "
   vBinExpNTC            (rp,k,z,z) "NTC flow only in one direction                 [0-1]         "
;
integer   variables
   vGenInvest    (     g)  "Integer generation investment [0-N]"
   vH2Invest     (   h2u)  "Integer H2 investment         [0-N]"
;
positive  variables
   vConsump        (rp,k,g        ) "consumption of the unit                                     [GW   ]"
   vPNS            (rp,k,i        ) "power  non   served                                         [GW   ]"
   vEPS            (rp,k,i        ) "excess power served                                         [GW   ]"
   vPNSZ           (rp,k,z        ) "power  non   served per zone                                [GW   ]"
   vEPSZ           (rp,k,z        ) "excess power served per zone                                [GW   ]"
   vStInterRes     ( p,  g        ) "reserve at the end   inter-per                              [GWh  ]"
   vStIntraRes     (rp,k,g        ) "reserve at the end   intra-per                              [GWh  ]"
   vSpillag        (rp,k,g        ) "spillage                                                    [GWh  ]"
   vWaterSell      (rp,k,g        ) "water sell - slack var (regret)                             [GWh  ]"
   v2ndResUP       (rp,k,g        ) "2nd res. up   allocation                                    [GW   ]"
   v2ndResDW       (rp,k,g        ) "2nd res. down allocation                                    [GW   ]"
   vGenP           (rp,k,g        ) "Real power gen. of the unit                                 [GW   ]"
   vGenP1          (rp,k,g        ) "Real power gen. of the unit > minload                       [GW   ]"
   vLineOverload   (rp,k,i,i,c    ) "line loading exceeding line load limit                      [%    ]"
   vDSM_Up         (rp,k,i,sec    ) "Demand-side managment Up (shifting)                         [GW   ]"
   vDSM_Dn         (rp,k,i,sec    ) "Demand-side managment Down (shifting)                       [GW   ]"
   vDSM_Shed       (rp,k,i,seg    ) "Price-responsiv Demand-side managment (shed)                [GW   ]"
   vCDSF_ch        (rp,k,g,a      ) "   charge for Cycle Depth Stress Function                   [GW   ]"
   vCDSF_dis       (rp,k,g,a      ) "discharge for Cycle Depth Stress Function                   [GW   ]"
   vCDSF_SoC       (rp,k,g,a      ) "Soc       for Cycle Depth Stress Function                   [GWh  ]"
   vSOCP_cii       (rp,k,i        ) "Auxiliary cii variable for SOCP formulation                 [p.u. ]"
   vSOCP_cij       (rp,k,i,i      ) "Auxiliary cij variable for SOCP formulation                 [p.u. ]"
   vDummySlackP    (rp,k,i,j      ) "Slack variable for Dummy objective function                        "
   vDummySlackN    (rp,k,i,j      ) "Slack variable for Dummy objective function                        "
   vRoCoF_k        (rp,k,g        ) "Scaled power gain factor of gen g                           [p.u. ]"
   vRoCoF_SysM     (rp,k          ) "Global system inertia                                       [s    ]"
   vRoCoF_SG_M     (rp,k          ) "System inertia provided by synch. machines                  [s    ]"
   vRoCoF_VI_M     (rp,k          ) "System inertia provided by virtual gen.                     [s    ]"
   vRoCoF_AuxY     (rp,k,g,g      ) "variable representing the product of binary vu and continuous vk   "
   vRoCoF_AuxW     (rp,k,g,g,m    ) "variable representing the product of binary vb and continuous vk   "
   vRoCoF_AuxZ     (rp,k,g        ) "variable representing the product of binary vu and continuous vM-SG"
   vRoCoF_AuxV     (rp,k,g  ,m    ) "variable representing the product of binary vb and continuous vM-VI"
   vRoCoF_SysM_AuxZ(rp,k,g        ) "variable representing the product of binary vu and continuous vM   "
   vRoCoF_SysM_AuxV(rp,k,g,  m    ) "variable representing the product of binary vb and continuous vM   "
   vCO2Overshoot                    "slack variable for CO2 budget overshoot                     [MtCO2]"
   vCO2Undershoot                   "slack variable for CO2 budget undershoot                    [MtCO2]"
   vH2NS           (rp,k,h2i,h2sec) "Hydrogen non-served                                         [t    ]"
   vH2Prod         (rp,k,h2u      ) "Hydrogen generation of the unit                             [t    ]"
   vH2Consump      (rp,k,h2u      ) "Power consumption of hydrogen the unit                      [GW   ]"
   vExpZP          (rp,k,z,z      ) "Export in zonal balance model                               [GW   ]"
   vImpZP          (rp,k,z,z      ) "Import in zonal balance model                               [GW   ]"
;
$offFold



*-------------------------------------------------------------------------------
*             Read input data from Excel and include into the model
*-------------------------------------------------------------------------------
$onFold // Define tables and helper sets ---------------------------------------

Sets
    tThermalGenColumns   /ExisUnits, MaxProd, MinProd, RampUp, RampDw, MinUpTime, MinDownTime, Qmax, Qmin, InertiaConst, FuelCost, Efficiency, CommitConsumption, OMVarCost, StartupConsumption, EFOR, EnableInvest, InvestCost, FirmCapCoef, CO2Emis, YearCom, YearDecom, lat, long, dataPackage, dataSource/
    tStorageColumns      /ExisUnits, MaxProd, MinProd, MaxCons, DisEffic, ChEffic, Qmax, Qmin, InertiaConst, MinReserve, IniReserve, IsHydro, OMVarCost, EnableInvest, MaxInvest, InvestCostPerMW, InvestCostPerMWh, Ene2PowRatio, ReplaceCost, ShelfLife, FirmCapCoef, CDSF_alpha, CDSF_beta /
    tRenewableColumns    /ExisUnits, MaxProd, EnableInvest, MaxInvest, InvestCost, OMVarCost, FirmCapCoef, Qmax, Qmin, InertiaConst/
    tFACTSColumns        /ExisUnits, Qmax, Qmin, EnableInvest, MaxInvest, InvestCost/
    tNetworkColumns      /pRLine, pXline, pBcline, pAngle, pRatio, pPmax, pEnableInvest, pFOMCost, pInvestCost, InService/
    tBusInfoColumns      /pBusBaseV, pBusMaxV, pBusMinV, pBusB, pBusG, pBus_pf/
    tImpExpDataColumns   /Import, Export, Price/
    tDSMprofileColumns   /Shift/
    tDSMshedColumns      /ShedPercentage, ShedPenalty/
    tZonesColumns        /minHydroDemand, minSolar, minWind, minBiomass, minRoRHydro, maxGas/
    tNTCColumns          /Pmax/
    tH2GenUnitsColumns   /ExisUnits, MaxCons, H2Effic, OMVarCost, PowerFactor, EnableInvest, InvestCost, MaxInvest/
    tH2NetworkColumns    /InService, Fmax/
;

Table    tDemand       (rp<   , i<  , k<                       );
Table    tThermalGen   (g<                , tThermalGenColumns );
Table    tStorage      (g<                , tStorageColumns    );
Table    tRunOfRiver   (g<                , tStorageColumns    );
Table    tInflows      (rp<   , g<  , k<                       );
Table    tRenewable    (g<                , tRenewableColumns  );
Table    tVRESProfiles (rp<   , g<        , k<                 );
Table    tFACTS        (g<                , tFACTSColumns      );
Table    tNetwork      (i<    , j<  , c<  , tNetworkColumns    );
Table    tBusInfo      (i<                , tBusInfoColumns    );
Table    tImpExpData   (i<    , rp< , k<  , tImpExpDataColumns );
Table    tDSMDelayTime (sec<  , rp<                            );
Table    tDSMprofile   (k<    , rp< , sec<, tDSMprofileColumns<);
Table    tDSMshed      (seg<              , tDSMshedColumns    );
Table    tDSMshiftcost (rp<   , i<  , k<                       );
Table    tZones        (z<                , tZonesColumns      );
Table    tNTC          (z<    , y<        , tNTCColumns        );
Table    tH2Demand     (h2sec<, k<  , rp< , h2i<               );
Table    tH2GenUnits   (h2u<              , tH2GenUnitsColumns );
Table    tH2Network    (h2i<  , h2j<      , tH2NetworkColumns  );

Parameters
    pSegmentsRoCoF
    pBlocksRoCoF
;

Sets
    g_help
    tec_help

    gtec_thermal_gen(g<, tec<)
    gtec_storage_ror_storageunits(g<, tec<)
    gtec_storage_ror_run_of_river(g<, tec<) 
    gtec_vres(g<, tec<)
    gtec_five(g<, tec<)
    gtec(g<,tec<)
    
    gi_help_thermal_gen(g<,tec<,i<)
    gi_help_storage_storage_units(g<,tec<,i<)
    gi_help_storage_run_of_river(g<,tec<,i<)
    gi_help_vres(g<,tec<,i<)
    gi_help_facts(g<,tec<,i<)
    
    h2gh2i_help(h2u<,h2tec<,i<,h2i<)
;
    
$onMulti
$offFold

$onFold // Read Global_Parameters ----------------------------------------------

$log Reading Global_Parameters.xlsx
$onEmbeddedCode Connect:
- ExcelReader:
    file: %scenarioFolder%/Global_Parameters.xlsx
    symbols:
        - name: pEnablePower
          range: Global Parameters!C5
          rowDimension: 0
          columnDimension: 0
          valueSubstitutions: {'Yes': true, 'No': false}
  
        - name: pEnableGas
          range: Global Parameters!C8
          rowDimension: 0
          columnDimension: 0
          valueSubstitutions: {'Yes': true, 'No': false}
          
        - name: pEnableHeat
          range: Global Parameters!C11
          rowDimension: 0
          columnDimension: 0
          valueSubstitutions: {'Yes': true, 'No': false}
          
        - name: pEnableH2
          range: Global Parameters!C14
          rowDimension: 0
          columnDimension: 0
          valueSubstitutions: {'Yes': true, 'No': false}
          
        - name: pEnableRMIP
          range: Global Parameters!C18
          rowDimension: 0
          columnDimension: 0
          valueSubstitutions: {'Yes': true, 'No': false}
          
        - name: pOutput
          range: Global Parameters!C22
          rowDimension: 0
          columnDimension: 0

        - name: pMovWindow
          range: Global Parameters!C26
          rowDimension: 0
          columnDimension: 0
          
- GAMSWriter:
    symbols: all

$offEmbeddedCode
$if not errorFree $abort 'Error reading Global_Parameters.xlsx';

* Evaluating and logging global parameters
$log Global parameters:

$eval pEnablePower pEnablePower
$log pEnablePower = %pEnablePower%

$eval pEnableGas pEnableGas
$log pEnableGas = %pEnableGas%

$eval pEnableHeat pEnableHeat
$log pEnableHeat = %pEnableHeat%

$eval pEnableH2 pEnableH2
$log pEnableH2 = %pEnableH2%

$offFold

$ifThenE.ExcelsPower (%pEnablePower%=1) // Power Sector Excels -----------------------

$onFold // Read Power_Parameters -----------------------------------------------

$log Reading Power_Parameters.xlsx
$onEmbeddedCode Connect:
    - ExcelReader:
        file: %scenarioFolder%/Power_Parameters.xlsx
        symbols:
            - name: is
              range: Power Parameters!C5
              rowDimension: 0
              columnDimension: 1
              type: set
              
            - name: pENSCost
              range: Power Parameters!C8
              rowDimension: 0
              columnDimension: 0
    
            - name: pSBase
              range: Power Parameters!C11
              rowDimension: 0
              columnDimension: 0
              
            - name: pSlackVoltage
              range: Power Parameters!C14
              rowDimension: 0
              columnDimension: 0

            # Module enable-flags not used
              
            - name: pEnableTransNet
              range: Power Parameters!C34
              rowDimension: 0
              columnDimension: 0
              valueSubstitutions: {'Yes': true, 'No': false}       
    
            - name: pEnableSOCP
              range: Power Parameters!C37
              rowDimension: 0
              columnDimension: 0
              valueSubstitutions: {'Yes': true, 'No': false}  
    
            - name: pMaxAngleDiff
              range: Power Parameters!C40
              rowDimension: 0
              columnDimension: 0
              
            - name: pMaxAngleDCOPF
              range: Power Parameters!C43
              rowDimension: 0
              columnDimension: 0
           
            - name: pEnableMaxLineLoad
              range: Power Parameters!C46
              rowDimension: 0
              columnDimension: 0
              valueSubstitutions: {'Yes': true, 'No': false}
              
            - name: pMaxLineLoad
              range: Power Parameters!C49
              rowDimension: 0
              columnDimension: 0
              
            - name: pLOLCost
              range: Power Parameters!C52
              rowDimension: 0
              columnDimension: 0
    
            - name: pMinGreenProd
              range: Power Parameters!C56
              rowDimension: 0
              columnDimension: 0
    
            - name: pEnableGreenNatBal
              range: Power Parameters!C59
              rowDimension: 0
              columnDimension: 0
              valueSubstitutions: {'Yes': true, 'No': false}
    
            - name: pEnableCO2
              range: Power Parameters!C63
              rowDimension: 0
              columnDimension: 0
              valueSubstitutions: {'Yes': true, 'No': false}
              
            - name: pCO2Budget
              range: Power Parameters!C66
              rowDimension: 0
              columnDimension: 0
              
            - name: pCO2Cost
              range: Power Parameters!C72
              rowDimension: 0
              columnDimension: 0
              
            - name: pCO2Penalty
              range: Power Parameters!C72
              rowDimension: 0
              columnDimension: 0
            
            - name: pMinFirmCap
              range: Power Parameters!C77
              rowDimension: 0
              columnDimension: 0
              
            - name: pEnableRoCoF
              range: Power Parameters!C81
              rowDimension: 0
              columnDimension: 0
              valueSubstitutions: {'Yes': true, 'No': false}
              
            - name: pBaseFreq
              range: Power Parameters!C84
              rowDimension: 0
              columnDimension: 0
    
            - name: pMinInertia
              range: Power Parameters!C87
              rowDimension: 0
              columnDimension: 0
              
            - name: pMaxRoCoF
              range: Power Parameters!C90
              rowDimension: 0
              columnDimension: 0
              
            - name: pSegmentsRoCoF
              range: Power Parameters!C93
              rowDimension: 0
              columnDimension: 0
    
            - name: pEnableDSMPower
              range: Power Parameters!C97
              rowDimension: 0
              columnDimension: 0
              valueSubstitutions: {'Yes': true, 'No': false}
    
            - name: pEnableZP
              range: Power Parameters!C101
              rowDimension: 0
              columnDimension: 0
              valueSubstitutions: {'Yes': true, 'No': false}
              
            - name: pNTCCost
              range: Power Parameters!C104
              rowDimension: 0
              columnDimension: 0
    
            - name: pEnableCDSF
              range: Power Parameters!C108
              rowDimension: 0
              columnDimension: 0
              valueSubstitutions: {'Yes': true, 'No': false}
    
            - name: pBlocksRoCoF
              range: Power Parameters!C111
              rowDimension: 0
              columnDimension: 0
              
            - name: pEnableChDisPower
              range: Power Parameters!C114
              rowDimension: 0
              columnDimension: 0
              valueSubstitutions: {'Yes': true, 'No': false}
              
            # - name: pFixStInterResToIniReserve               # NOT IMPLEMENTED
            #   range: Power Parameters!C117
            #   rowDimension: 0
            #   columnDimension: 0
    
            - name: pEnableMinProdRESTech
              range: Power Parameters!C121
              rowDimension: 0
              columnDimension: 0
              valueSubstitutions: {'Yes': true, 'No': false}
              
            - name: pEnableMaxGas
              range: Power Parameters!C124
              rowDimension: 0
              columnDimension: 0
              valueSubstitutions: {'Yes': true, 'No': false}

            - name: p2ndResUp
              range: Power Parameters!C128
              rowDimension: 0
              columnDimension: 0
                
            - name: p2ndResDw
              range: Power Parameters!C131
              rowDimension: 0
              columnDimension: 0
              
            - name: p2ndResUpCost
              range: Power Parameters!C134
              rowDimension: 0
              columnDimension: 0
                
            - name: p2ndResDwCost
              range: Power Parameters!C137
              rowDimension: 0
              columnDimension: 0

    - GAMSWriter:
        symbols: all
        
    - PythonCode:
        code: |
            # use range to set compute set 'a'
            a_max = connect.container["pBlocksRoCoF"].records.values[0][0]
            a_max_digits = len(str(int(a_max)))
            a_values = [f"a{i:0{a_max_digits}}" for i in range(1, int(a_max) + 1)]
            connect.container.addSet('a', ['*'], records=a_values)

            # use range to set compute set 'm'
            m_max = connect.container["pSegmentsRoCoF"].records.values[0][0]
            m_max_digits = len(str(int(m_max)))
            m_values = [f"m{i:0{m_max_digits}}" for i in range(1, int(m_max) + 1)]
            connect.container.addSet('m', ['*'], records=m_values)
            
    - GAMSWriter:
        symbols:
          - name: a
          - name: m
                    

$offEmbeddedCode
$if not errorFree $abort 'Error reading Power_Parameters.xlsx';

* Evaluating and logging power parameters
$log Power parameters:

$eval pEnableZP pEnableZP
$log pEnableZP = %pEnableZP%

$offFold

$onFold // Read Power_Zones ----------------------------------------------------

$log Reading Power_Zones.xlsx
$onEmbeddedCode Connect:         
- ExcelReader:
    file: %scenarioFolder%/Power_Zones.xlsx
    symbols:
        - name: tZones
          range: Power Zones!B3
          rowDimension: 1
          columnDimension: 1
          ignoreRows: [4, 5, 6]

- GAMSWriter:
    symbols: all

$offEmbeddedCode
$if not errorFree $abort 'Error reading Power_Zones.xlsx';
$offFold

$onFold // Read Power_Demand ---------------------------------------------------
$log Reading Power_Demand.xlsx
$onEmbeddedCode Connect:
- GAMSReader:
    symbols:
        - name: tDemand
- PythonCode:
    code: |
        import pandas as pd
        
        filePath = r"%scenarioFolder%/Power_Demand.xlsx"
        xls = pd.ExcelFile(filePath)
        
        # Get the Gams-Parameters
        gamsParameters = connect.container.getSymbols()
        tDemand = next((x for x in gamsParameters if x.name == "tDemand"), None)

        df = xls.parse(skiprows=[0, 1, 2, 4, 5, 6])
        
        # Replace empty cells with 0
        df = df.fillna(0)
        
        # Transpose table for tDemand
        tDemand.setRecords(pd.melt(df.drop(['dataPackage', 'dataSource'], axis=1), id_vars=["rp", "i"],
                                       var_name="k", value_name="Value"))
- GAMSWriter:
    symbols:
        - name: tDemand
$offEmbeddedCode
$if not errorFree $abort 'Error reading Power_Demand.xlsx';
$offFold

$onFold // Read Power_Tec -----------------------------------------------------

$log Reading Power_Tec.xlsx
$onEmbeddedCode Connect:
        
- ExcelReader:
    file: %scenarioFolder%/Power_Tec.xlsx
    symbols:
        - name: tec
          range: Power Tec!B5
          rowDimension: 1
          columnDimension: 0
          type: set

- GAMSWriter:
    symbols: all

$offEmbeddedCode
$if not errorFree $abort 'Error reading Power_Tec.xlsx';
$offFold

$onFold // Read Power_ThermalGen -----------------------------------------------
$log Reading Power_ThermalGen.xlsx
$onEmbeddedCode Connect:
- GAMSReader:
    symbols:
        - name: tThermalGen
        - name: gtec_thermal_gen
        - name: gi_help_thermal_gen
- PythonCode:
    code: |
        import pandas as pd
        
        filePath = r"%scenarioFolder%/Power_ThermalGen.xlsx"
        xls = pd.ExcelFile(filePath)
        
        # Get the Gams-Parameters
        gamsParameters = connect.container.getSymbols()
        tThermalGen = next((x for x in gamsParameters if x.name == "tThermalGen"), None)
        gtec_thermal_gen = next((x for x in gamsParameters if x.name == "gtec_thermal_gen"), None)
        gi_help_thermal_gen = next((x for x in gamsParameters if x.name == "gi_help_thermal_gen"), None)

        df = xls.parse(skiprows=[0, 1, 2, 4, 5, 6])
        
        # Drop rows where "excl"-Column is filled, only keep empty ones
        df = df[pd.isna(df['excl'])]
        
        # Drop all columns starting from given column (and all to the right of it)
        df = df.drop(columns=df.columns[df.columns.get_loc("YearCom"):], axis=1)
        
        # Replace empty cells with 0
        df = df.infer_objects(copy=False).fillna(0)
        
        # Skip columns "tec" and "i" & transpose table for tThermalGen
        tThermalGen.setRecords(pd.melt(df.drop(['excl', 'tec', 'i'], axis=1), id_vars=["g"],
                                       var_name="tThermalGenColumns", value_name="Value"))
                                       
        # Create df for gtec_thermal_gen & gi_help_thermal_gen and set records
        gtec_thermal_gen.setRecords(df[['g', 'tec']])
        gi_help_thermal_gen.setRecords(df[['g', 'tec', 'i']])
- GAMSWriter:
    symbols:
        - name: tThermalGen
        - name: gtec_thermal_gen
        - name: gi_help_thermal_gen
$offEmbeddedCode
$if not errorFree $abort 'Error reading Power_ThermalGen.xlsx';
$offFold

$onFold // Read Power_Storage --------------------------------------------------
$log Reading Power_Storage.xlsx
$onEmbeddedCode Connect:
- GAMSReader:
    symbols:
        - name: tStorage
        - name: gtec_storage_ror_storageunits
        - name: gi_help_storage_storage_units
- PythonCode:
    code: |
        import pandas as pd
        
        filePath = r"%scenarioFolder%/Power_Storage.xlsx"
        xls = pd.ExcelFile(filePath)
        
        # Get the Gams-Parameters
        gamsParameters = connect.container.getSymbols()
        tStorage = next((x for x in gamsParameters if x.name == "tStorage"), None)
        gtec_storage_ror_storageunits = next((x for x in gamsParameters if x.name == "gtec_storage_ror_storageunits"), None)
        gi_help_storage_storage_units = next((x for x in gamsParameters if x.name == "gi_help_storage_storage_units"), None)

        df = xls.parse(sheet_name="Power Storage",
                       skiprows=[0, 1, 3, 4, 5])
        
        # Rename columns and set scenario name for each entry of this sheet
        df = df.rename(columns={df.columns[0]: "Excl.", df.columns[1]: "g", df.columns[2]: "tec", df.columns[3]: "i"})
        
        # Drop rows where "Excl."-Column is filled, only keep empty ones
        df = df[pd.isna(df['Excl.'])]
        
        # Drop all columns starting from given column (and all to the right of it)
        df = df.drop(columns=df.columns[df.columns.get_loc("PPName"):], axis=1)
        
        # Replace empty cells with 0
        df = df.fillna(0)
        
        # Skip columns "tec" and "i" & transpose table for tStorage
        tStorage.setRecords(pd.melt(df.drop(['Excl.', 'tec', 'i'], axis=1), id_vars=["g"],
                                       var_name="tStorageColumns", value_name="Value"))
                                       
        # Create df for gtec_storage_ror_storageunits & gi_help_storage_storage_units and set records
        gtec_storage_ror_storageunits.setRecords(df[['g', 'tec']])
        gi_help_storage_storage_units.setRecords(df[['g', 'tec', 'i']])
- GAMSWriter:
    symbols:
        - name: tStorage
        - name: gtec_storage_ror_storageunits
        - name: gi_help_storage_storage_units
$offEmbeddedCode
$if not errorFree $abort 'Error reading Power_Storage.xlsx';
$offFold

$onFold // Read Power_RoR ------------------------------------------------------
$log Reading Power_RoR.xlsx
$onEmbeddedCode Connect:
- GAMSReader:
    symbols:
        - name: tRunOfRiver
        - name: gtec_storage_ror_run_of_river
        - name: gi_help_storage_run_of_river
- PythonCode:
    code: |
        import pandas as pd
        
        filePath = r"%scenarioFolder%/Power_RoR.xlsx"
        xls = pd.ExcelFile(filePath)
        
        # Get the Gams-Parameters
        gamsParameters = connect.container.getSymbols()
        tRunOfRiver = next((x for x in gamsParameters if x.name == "tRunOfRiver"), None)
        gtec_storage_ror_run_of_river = next((x for x in gamsParameters if x.name == "gtec_storage_ror_run_of_river"), None)
        gi_help_storage_run_of_river = next((x for x in gamsParameters if x.name == "gi_help_storage_run_of_river"), None)

        df = xls.parse(sheet_name="Power RoR",
                       skiprows=[0, 1, 3, 4, 5])
        
        # Rename columns and set scenario name for each entry of this sheet
        df = df.rename(columns={df.columns[0]: "excl", df.columns[1]: "g", df.columns[2]: "tec", df.columns[3]: "i"})
        
        # Drop rows where "excl"-Column is filled, only keep empty ones
        df = df[pd.isna(df['excl'])]
        
        # Drop all columns starting from given column (and all to the right of it)
        df = df.drop(columns=df.columns[df.columns.get_loc("PPName"):], axis=1)
        
        # Replace empty cells with 0
        df = df.fillna(0)
        
        # Skip columns "tec" and "i" & transpose table for tRunOfRiver
        tRunOfRiver.setRecords(pd.melt(df.drop(['excl', 'tec', 'i'], axis=1), id_vars=["g"],
                                       var_name="tStorageColumns", value_name="Value"))
                                       
        # Create df for gtec_storage_ror_run_of_river & gi_help_storage_run_of_river and set records
        gtec_storage_ror_run_of_river.setRecords(df[['g', 'tec']])
        gi_help_storage_run_of_river.setRecords(df[['g', 'tec', 'i']])
- GAMSWriter:
    symbols:
        - name: tRunOfRiver
        - name: gtec_storage_ror_run_of_river
        - name: gi_help_storage_run_of_river
$offEmbeddedCode
$if not errorFree $abort 'Error reading Power_RoR.xlsx';
$offFold

$onFold // Read Power_Inflows --------------------------------------------------

$log Reading Power_Inflows.xlsx
$onEmbeddedCode Connect:

- ExcelReader:
    file: %scenarioFolder%/Power_Inflows.xlsx
    symbols:          
        - name: tInflows
          range: Power Inflows!B3
          rowDimension: 2
          columnDimension: 1
          ignoreRows: [4, 5, 6]
          type: par

- GAMSWriter:
    symbols: all

$offEmbeddedCode
$if not errorFree $abort 'Error reading Power_Inflows.xlsx';
$offFold

$onFold // Read Power_VRES -----------------------------------------------------
$log Reading Power_VRES.xlsx
$onEmbeddedCode Connect:
- GAMSReader:
    symbols:
        - name: tRenewable
        - name: gtec_vres
        - name: gi_help_vres
- PythonCode:
    code: |
        import pandas as pd
        
        filePath = r"%scenarioFolder%/Power_VRES.xlsx"
        xls = pd.ExcelFile(filePath)
        
        # Get the Gams-Parameters
        gamsParameters = connect.container.getSymbols()
        tRenewable = next((x for x in gamsParameters if x.name == "tRenewable"), None)
        gtec_vres = next((x for x in gamsParameters if x.name == "gtec_vres"), None)
        gi_help_vres = next((x for x in gamsParameters if x.name == "gi_help_vres"), None)

        df = xls.parse(skiprows=[0, 1, 2, 4, 5, 6])
        
        # Drop rows where "excl"-Column is filled, only keep empty ones
        df = df[pd.isna(df['excl'])]
        
        # Drop all columns starting from given column (and all to the right of it)
        df = df.drop(columns=df.columns[df.columns.get_loc("YearCom"):], axis=1)
        
        # Replace empty cells with 0
        df = df.fillna(0)
        
        # Skip columns "tec" and "i" & transpose table for tRenewable
        tRenewable.setRecords(pd.melt(df.drop(['excl', 'tec', 'i'], axis=1), id_vars=["g"],
                                       var_name="tRenewableColumns", value_name="Value"))
                                       
        # Create df for gtec_vres & gi_help_vres and set records
        gtec_vres.setRecords(df[['g', 'tec']])
        gi_help_vres.setRecords(df[['g', 'tec', 'i']])
- GAMSWriter:
    symbols:
        - name: tRenewable
        - name: gtec_vres
        - name: gi_help_vres
$offEmbeddedCode
$if not errorFree $abort 'Error reading Power_VRES.xlsx';
$offFold

$onFold // Read Power_VRESProfiles ---------------------------------------------
$log Reading Power_VRESProfiles.xlsx
$onEmbeddedCode Connect:
- GAMSReader:
    symbols:
        - name: tVRESProfiles
- PythonCode:
    code: |
        import pandas as pd

        filePath = r"%scenarioFolder%/Power_VRESProfiles.xlsx"
        xls = pd.ExcelFile(filePath)

        # Get the Gams-Parameters
        gamsParameters = connect.container.getSymbols()
        tVRESProfiles = next((x for x in gamsParameters if x.name == "tVRESProfiles"), None)

        df = xls.parse(skiprows=[0, 1, 2, 4, 5, 6])

        # Replace empty cells with 0
        df = df.fillna(0)

        # Transpose table
        tVRESProfiles.setRecords(pd.melt(df.drop(['id', 'dataPackage', 'dataSource'], axis=1), id_vars=["rp", "g"],
                                       var_name="k", value_name="Value"))
- GAMSWriter:
    symbols:
        - name: tVRESProfiles

$offEmbeddedCode
$if not errorFree $abort 'Error reading Power_VRESProfiles.xlsx';
$offFold

$onFold // Read Power_FACTS ----------------------------------------------------
$log Reading Power_FACTS.xlsx
$onEmbeddedCode Connect:
- GAMSReader:
    symbols:
        - name: tFACTS
        - name: gtec_five
        - name: gi_help_facts
- PythonCode:
    code: |
        import pandas as pd
        
        filePath = r"%scenarioFolder%/Power_FACTS.xlsx"
        xls = pd.ExcelFile(filePath)
        
        # Get the Gams-Parameters
        gamsParameters = connect.container.getSymbols()
        tFACTS = next((x for x in gamsParameters if x.name == "tFACTS"), None)
        gtec_five = next((x for x in gamsParameters if x.name == "gtec_five"), None)
        gi_help_facts = next((x for x in gamsParameters if x.name == "gi_help_facts"), None)

        df = xls.parse(sheet_name="Power FACTS",
                       skiprows=[0, 1, 3, 4, 5])
        
        # Rename columns and set scenario name for each entry of this sheet
        df = df.rename(columns={df.columns[0]: "excl", df.columns[1]: "g", df.columns[2]: "tec", df.columns[3]: "i"})
        
        # Drop rows where "excl"-Column is filled, only keep empty ones
        df = df[pd.isna(df['excl'])]
        
        # Drop all columns starting from given column (and all to the right of it)
        df = df.drop(columns=df.columns[df.columns.get_loc("PPName"):], axis=1)
        
        # Replace empty cells with 0
        df = df.fillna(0)
        
        # Skip columns "tec" and "i" & transpose table for tFACTS
        tFACTS.setRecords(pd.melt(df.drop(['excl', 'tec', 'i'], axis=1), id_vars=["g"],
                                       var_name="tFACTSColumns", value_name="Value"))
                                       
        # Create df for gtec_five & gi_help_facts and set records
        gtec_five.setRecords(df[['g', 'tec']])
        gi_help_facts.setRecords(df[['g', 'tec', 'i']])
- GAMSWriter:
    symbols:
        - name: tFACTS
        - name: gtec_five
        - name: gi_help_facts
$offEmbeddedCode
$if not errorFree $abort 'Error reading Power_FACTS.xlsx';
$offFold

$onFold // Read Power_WeightsRP -----------------------------------------------
$log Reading Power_WeightsRP.xlsx
$onEmbeddedCode Connect:
- GAMSReader:
    symbols:
        - name: pWeight_rp
- PythonCode:
    code: |
        import pandas as pd

        filePath = r"%scenarioFolder%/Power_WeightsRP.xlsx"
        xls = pd.ExcelFile(filePath)

        # Get the Gams-Parameters
        gamsParameters = connect.container.getSymbols()
        pWeight_rp = next((x for x in gamsParameters if x.name == "pWeight_rp"), None)

        df = xls.parse(skiprows=[0, 1, 2, 4, 5, 6])

        # Drop all columns starting from given column (and all to the right of it)
        df = df.drop(columns=df.columns[df.columns.get_loc("dataPackage"):], axis=1)

        # Drop very first and 'id' column
        df = df.drop([df.columns[0], 'id'], axis=1)

        pWeight_rp.setRecords(df)
- GAMSWriter:
    symbols:
        - name: pWeight_rp
$offEmbeddedCode
$if not errorFree $abort 'Error reading Power_WeightsRP.xlsx';
$offFold

$onFold // Read Power_WeightsK -----------------------------------------------
$log Reading Power_WeightsK.xlsx
$onEmbeddedCode Connect:
- GAMSReader:
    symbols:
        - name: pWeight_k
- PythonCode:
    code: |
        import pandas as pd

        filePath = r"%scenarioFolder%/Power_WeightsK.xlsx"
        xls = pd.ExcelFile(filePath)

        # Get the Gams-Parameters
        gamsParameters = connect.container.getSymbols()
        pWeight_k = next((x for x in gamsParameters if x.name == "pWeight_k"), None)

        df = xls.parse(skiprows=[0, 1, 2, 4, 5, 6])

        # Drop all columns starting from given column (and all to the right of it)
        df = df.drop(columns=df.columns[df.columns.get_loc("dataPackage"):], axis=1)

        # Drop very first and 'id' column
        df = df.drop([df.columns[0], 'id'], axis=1)

        pWeight_k.setRecords(df)
- GAMSWriter:
    symbols:
        - name: pWeight_k
$offEmbeddedCode
$if not errorFree $abort 'Error reading Power_WeightsK.xlsx';
$offFold

$onFold // Read Power_Hindex -----------------------------------------------
$log Reading Power_Hindex.xlsx
$onEmbeddedCode Connect:
- GAMSReader:
    symbols:
        - name: hindex
- PythonCode:
    code: |
        import pandas as pd

        filePath = r"%scenarioFolder%/Power_Hindex.xlsx"
        xls = pd.ExcelFile(filePath)

        # Get the Gams-Parameters
        gamsParameters = connect.container.getSymbols()
        hindex = next((x for x in gamsParameters if x.name == "hindex"), None)

        df = xls.parse(skiprows=[0, 1, 2, 4, 5, 6])

        # Drop all columns starting from given column (and all to the right of it)
        df = df.drop(columns=df.columns[df.columns.get_loc("dataPackage"):], axis=1)

        # Drop very first and 'id' column
        df = df.drop([df.columns[0], 'id'], axis=1)

        hindex.setRecords(df)
- GAMSWriter:
    symbols:
        - name: hindex
$offEmbeddedCode
$if not errorFree $abort 'Error reading Power_Hindex.xlsx';
$offFold

$onFold // Read Power_Network --------------------------------------------------
$log Reading Power_Network.xlsx
$onEmbeddedCode Connect:
- GAMSReader:
    symbols:
        - name: tNetwork
- PythonCode:
    code: |
        import pandas as pd
        import numpy as np
        
        filePath = r"%scenarioFolder%/Power_Network.xlsx"
        xls = pd.ExcelFile(filePath)
        
        # Get the Gams-Parameters
        gamsParameters = connect.container.getSymbols()
        tNetwork = next((x for x in gamsParameters if x.name == "tNetwork"), None)

        df = xls.parse(skiprows=[0, 1, 2, 4, 5, 6])

        # Drop rows where "excl"-Column is filled, only keep empty ones
        df = df[pd.isna(df['excl'])]
        
        # Drop all columns starting from given column (and all to the right of it)
        df = df.drop(columns=df.columns[df.columns.get_loc("pTecRepr"):], axis=1)

        # Add (now obsolete) columns from old file format

        df["InService"] = 1 
            
        # Replace empty cells with 0
        df = df.infer_objects(copy=False).fillna(0)
        
        # Skip columns "tec" and "i" & transpose table for tNetwork
        tNetwork.setRecords(pd.melt(df, id_vars=['i', 'j', 'c'],
                                       var_name="tNetworkColumns", value_name="Value"))
- GAMSWriter:
    symbols:
        - name: tNetwork
$offEmbeddedCode
$if not errorFree $abort 'Error reading Power_Network.xlsx';
$offFold

$onFold // Read Power_BusInfo --------------------------------------------------
$log Reading Power_BusInfo.xlsx
$onEmbeddedCode Connect:
- GAMSReader:
    symbols:
        - name: tBusInfo
        - name: iz
- PythonCode:
    code: |
        import pandas as pd
        
        filePath = r"%scenarioFolder%/Power_BusInfo.xlsx"
        xls = pd.ExcelFile(filePath)
        
        # Get the Gams-Parameters
        gamsParameters = connect.container.getSymbols()
        tBusInfo = next((x for x in gamsParameters if x.name == "tBusInfo"), None)
        iz = next((x for x in gamsParameters if x.name == "iz"), None)

        df = xls.parse(skiprows=[0, 1, 2, 4, 5, 6])
        
        # Drop rows where "excl"-Column is filled, only keep empty ones
        df = df[pd.isna(df['excl'])]
        
        # Drop all columns starting from given column (and all to the right of it)
        df = df.drop(columns=df.columns[df.columns.get_loc("YearCom"):], axis=1)
        
        # Replace empty cells with 0
        df = df.fillna(0)
        
        # Skip column "z" & transpose table for tBusInfo
        tBusInfo.setRecords(pd.melt(df.drop(['excl', 'z', 'id'], axis=1), id_vars=["i"],
                                       var_name="tBusInfoColumns", value_name="Value"))
                                       
        # Create df for iz and set records
        iz.setRecords(df[['i', 'z']])
- GAMSWriter:
    symbols:
        - name: tBusInfo
        - name: iz
$offEmbeddedCode
$if not errorFree $abort 'Error reading Power_BusInfo.xlsx';
$offFold

*$onFold // Read Power_ImpExp ---------------------------------------------------
*
*$log Reading Power_ImpExp.xlsx
*$onEmbeddedCode Connect:
*
*- ExcelReader:
*    file: %scenarioFolder%/Power_ImpExp.xlsx
*    symbols:
*        - name: tImpExpData
*          range: Power ImpExp!B3
*          rowDimension: 3
*          columnDimension: 1
*          ignoreRows: [4, 5, 6]
*
*- GAMSWriter:
*    symbols: all
*
*$offEmbeddedCode
*$if not errorFree $abort 'Error reading Power_ImpExp.xlsx';
*$offFold

$onFold // Read Power_DSM ------------------------------------------------------

$log Reading Power_DSM.xlsx
$onEmbeddedCode Connect:

- ExcelReader:
    file: %scenarioFolder%/Power_DSM.xlsx
    symbols:
        - name: tDSMDelayTime
          range: DSM-DelayTime!B7
          rowDimension: 1
          columnDimension: 1

        - name: tDSMprofile
          range: DSM-Max!B3
          rowDimension: 1
          columnDimension: 3
          
        - name: tDSMshiftcost
          range: DSM-shift!B3
          rowDimension: 2
          columnDimension: 1

        - name: tDSMshed
          range: DSM-shed!B3
          rowDimension: 1
          columnDimension: 1
          ignoreRows: [4, 5, 6]

- GAMSWriter:
    symbols: all

$offEmbeddedCode
$if not errorFree $abort 'Error reading Power_DSM.xlsx';
$offFold

$onFold // Read Power_NTC ------------------------------------------------------

$log Reading Power_NTC.xlsx
$ifThenE.ZonalPricing (%pEnableZP%=1)
$onEmbeddedCode Connect:
    
    - ExcelReader:
        file: %scenarioFolder%/Power_NTC.xlsx
        symbols:
            - name: tNTC
              range: Power NTC!B3
              rowDimension: 2
              columnDimension: 1
              ignoreRows: [4, 5, 6]
    
    - GAMSWriter:
        symbols: all
    
$offEmbeddedCode
$if not errorFree $abort 'Error reading Power_NTC.xlsx';
$endIf.ZonalPricing
$offFold

$onFold // Python Code to join helper Sets -------------------------------------

$log Python Code to join helper Sets
$onEmbeddedCode Connect:
- GAMSReader:
    symbols:
      - name: gtec_thermal_gen
      - name: gtec_storage_ror_storageunits
      - name: gtec_storage_ror_run_of_river
      - name: gtec_vres
      - name: gtec_five
      - name: gi_help_thermal_gen
      - name: gi_help_storage_storage_units
      - name: gi_help_storage_run_of_river
      - name: gi_help_vres
      - name: gi_help_facts

- PythonCode:
    code: |
        # merge gtec_thermal_gen .. gtec_5  'gtec'
        g1 = list() if connect.container.data["gtec_thermal_gen"].records is None else connect.container.data["gtec_thermal_gen"].records.values.tolist()
        g2 = list() if connect.container.data["gtec_storage_ror_storageunits"].records is None else connect.container.data["gtec_storage_ror_storageunits"].records.values.tolist()
        g3 = list() if connect.container.data["gtec_storage_ror_run_of_river"].records is None else connect.container.data["gtec_storage_ror_run_of_river"].records.values.tolist()
        g4 = list() if connect.container.data["gtec_vres"].records is None else connect.container.data["gtec_vres"].records.values.tolist()
        g5 = list() if connect.container.data["gtec_five"].records is None else connect.container.data["gtec_five"].records.values.tolist()
        
        gtec = g1 + g2 + g3 + g4 + g5
        gtec = list(set([(g,tec) for [g,tec,_] in gtec]))
        connect.container.addSet('gtec', ['g','tec'], records=gtec)

        gi_help_thermal_gen = list() if connect.container.data["gi_help_thermal_gen"].records is None else connect.container.data["gi_help_thermal_gen"].records.values.tolist()
        gi_help_thermal_gen = [(g,i) for (g,_,i,_) in gi_help_thermal_gen]
        gi_help_storage_storage_units = list() if connect.container.data["gi_help_storage_storage_units"].records is None else connect.container.data["gi_help_storage_storage_units"].records.values.tolist()
        gi_help_storage_storage_units = [(g,i) for (g,_,i,_) in gi_help_storage_storage_units]
        gi_help_storage_run_of_river = list() if connect.container.data["gi_help_storage_run_of_river"].records is None else connect.container.data["gi_help_storage_run_of_river"].records.values.tolist()
        gi_help_storage_run_of_river = [(g,i) for (g,_,i,_) in gi_help_storage_run_of_river]
        gi_help_vres = list() if connect.container.data["gi_help_vres"].records is None else connect.container.data["gi_help_vres"].records.values.tolist()
        gi_help_vres = [(g,i) for (g,_,i,_) in gi_help_vres]
        gi_help_facts = list() if connect.container.data["gi_help_facts"].records is None else connect.container.data["gi_help_facts"].records.values.tolist()
        gi_help_facts = [(g,i) for (g,_,i,_) in gi_help_facts]

        gi = list(set(gi_help_thermal_gen + gi_help_storage_storage_units + gi_help_storage_run_of_river + gi_help_vres + gi_help_facts))
        connect.container.addSet('gi', ['g','i'], records=gi)
        
- GAMSWriter:
    symbols: all

$offEmbeddedCode
$if not errorFree $abort 'Error in python Code to join helper Sets';
$offFold

$endIf.ExcelsPower

$ifThenE.ExcelsH2 (%pEnableH2%=1) // H2 Sector Excels --------------------------------

$onFold // Read Gas_Parameters -------------------------------------------------

$log Reading Gas_Parameters.xlsx
$onEmbeddedCode Connect:

- ExcelReader:
    file: %scenarioFolder%/Gas_Parameters.xlsx
    symbols:
        - name: pH2NSCost
          range: Parameters!C5
          rowDimension: 0
          columnDimension: 0
          
        - name: h2tec
          range: Parameters!C8
          rowDimension: 0
          columnDimension: 1
          type: set

- GAMSWriter:
    symbols: all

$offEmbeddedCode
$if not errorFree $abort 'Error reading Gas_Parameters.xlsx';
$offFold

$onFold // Read Gas_H2_Demand --------------------------------------------------

$log Reading Gas_H2_Demand.xlsx
$onEmbeddedCode Connect:

- ExcelReader:
    file: %scenarioFolder%/Gas_H2_Demand.xlsx
    symbols:
        - name: tH2Demand
          range: Gas H2 Demand!B5
          rowDimension: 2
          columnDimension: 2

- GAMSWriter:
    symbols: all

$offEmbeddedCode

$if not errorFree $abort 'Error reading Gas_H2_Demand.xlsx';
$offFold

$onFold // Read Gas_H2_GenUnits ------------------------------------------------
$log Reading Gas_H2_GenUnits.xlsx
$onEmbeddedCode Connect:
- GAMSReader:
    symbols:
        - name: tH2GenUnits
        - name: h2g
        - name: h2uh2tec
        - name: h2gh2i_help
        - name: h2gi
        - name: h2gh2i
- PythonCode:
    code: |
        import pandas as pd
        
        filePath = r"%scenarioFolder%/Gas_H2_GenUnits.xlsx"
        xls = pd.ExcelFile(filePath)
        
        # Get the Gams-Parameters
        gamsParameters = connect.container.getSymbols()
        tH2GenUnits = next((x for x in gamsParameters if x.name == "tH2GenUnits"), None)
        h2g = next((x for x in gamsParameters if x.name == "h2g"), None)
        h2uh2tec = next((x for x in gamsParameters if x.name == "h2uh2tec"), None)
        h2gh2i_help = next((x for x in gamsParameters if x.name == "h2gh2i_help"), None)
        h2gi = next((x for x in gamsParameters if x.name == "h2gi"), None)
        h2gh2i = next((x for x in gamsParameters if x.name == "h2gh2i"), None)

        df = xls.parse(sheet_name="Gas H2 GenUnits",
                       skiprows=[0, 1, 3, 4, 5])
        
        # Rename columns and set scenario name for each entry of this sheet
        df = df.rename(columns={df.columns[0]: "excl", df.columns[1]: "h2u", df.columns[2]: "h2tec", df.columns[3]: "i", df.columns[4]: "h2i"})
        
        # Drop rows where "excl"-Column is filled, only keep empty ones
        df = df[pd.isna(df['excl'])]
        
        # Drop all columns starting from given column (and all to the right of it)
        df = df.drop(columns=df.columns[df.columns.get_loc("MaxInvest")+1:], axis=1)
        
        # Replace empty cells with 0
        df = df.fillna(0)
        
        # Skip columns "tec" and "i" & transpose table for tH2GenUnits
        tH2GenUnits.setRecords(pd.melt(df.drop(['excl', 'h2tec', 'i', 'h2i'], axis=1), id_vars=["h2u"],
                                       var_name="tH2GenUnitsColumns", value_name="Value"))
                                       
        # Create df for other symbols and set records
        h2g.setRecords(df[['h2u']])
        h2uh2tec.setRecords(df[['h2u', 'h2tec']])
        h2gh2i_help.setRecords(df[['h2u', 'h2tec', 'i', 'h2i']])
        h2gi.setRecords(df[['h2u', 'i']])
        h2gh2i.setRecords(df[['h2u', 'h2i']])
- GAMSWriter:
    symbols:
        - name: tH2GenUnits
        - name: h2g
        - name: h2uh2tec
        - name: h2gh2i_help
        - name: h2gi
        - name: h2gh2i
$offEmbeddedCode
$if not errorFree $abort 'Error reading Gas_H2_GenUnits.xlsx';
$offFold

$onFold // Read Gas_H2_Network -------------------------------------------------
$log Reading Gas_H2_Network.xlsx
$onEmbeddedCode Connect:
- GAMSReader:
    symbols:
        - name: tH2Network
- PythonCode:
    code: |
        import pandas as pd
        
        filePath = r"%scenarioFolder%/Gas_H2_Network.xlsx"
        xls = pd.ExcelFile(filePath)
        
        # Get the Gams-Parameters
        gamsParameters = connect.container.getSymbols()
        tH2Network = next((x for x in gamsParameters if x.name == "tH2Network"), None)

        df = xls.parse(sheet_name="Gas H2 Network",
                       skiprows=[0, 1, 3, 4, 5])
        
        # Rename columns and set scenario name for each entry of this sheet
        df = df.rename(columns={df.columns[0]: "excl", df.columns[1]: "h2i", df.columns[2]: "h2j"})
        
        # Drop rows where "excl"-Column is filled, only keep empty ones
        df = df[pd.isna(df['excl'])]
        
        # Replace empty cells with 0
        df = df.fillna(0)
        
        # Transpose table for tH2Network
        tH2Network.setRecords(pd.melt(df.drop(['excl'], axis=1), id_vars=["h2i", "h2j"],
                                       var_name="tH2NetworkColumns", value_name="Value"))
- GAMSWriter:
    symbols:
        - name: tH2Network
$offEmbeddedCode
$if not errorFree $abort 'Error reading Gas_H2_Network.xlsx';
$offFold

$endIf.ExcelsH2


*-------------------------------------------------------------------------------
*                         Declaration of Equations
*-------------------------------------------------------------------------------
equations

$onFold // Declaration Objective Function --------------------------------------

   eTotalVCost                 "total system variable cost                   [M€] "

$offFold   

$onFold // Declaration General System Constraints ------------------------------

   eCleanProdLimThermal        "Maximum                  thermal production  [GWh]"
   eCleanProdNatBal            "Minimum national balance green   production  [GWh]"
   eFirmCapCon                 "firm capacity constraint                     [GW] "
   e2ReserveUp   (rp,k      )  "2nd reserve up   reserve                     [GW] "
   e2ReserveDw   (rp,k      )  "2nd reserve down reserve                     [GW] "
   eMinInertia   (rp,k      )  "minimum inertia running in the power system  [s ] "

$offFold

$ifThenE.DeclarationsPower (%pEnablePower%=1) // Declaration Power Sector Constraints

$onFold // Declaration Single Node Constraints ---------------------------------

   eSN_BalanceP  (rp,k,i    )  "load generation balance single node          [GW] " 

$offFold

$onFold // Declaration Unit Commitment Constraints -----------------------------

   eUCMaxOut1    (rp,k,g    )  "output limit 1 of a committed unit           [GW] "
   eUCMaxOut2    (rp,k,g    )  "output limit 2 of a committed unit           [GW] "
   eUCMinOut     (rp,k,g    )  "output limit   of a committed unit           [GW] "
   eUCTotOut     (rp,k,g    )  "total output of a committed unit             [GW] "
   eUCStrShut    (rp,k,g    )  "relation among committment startup and shutdown   "
   eThRampUp     (rp,k,g    )  "ramp up limit for thermal units              [GW] "
   eThRampDw     (rp,k,g    )  "ramp dw limit for thermal units              [GW] "
   eThMaxUC      (rp,k,g    )  "maximum thermal units investment                  "
   
$offFold

$onFold // Declaration Energy Storage Constraints ------------------------------

   eStIntraRes   (rp,k,g    )  "intra-period storage reserve or SoC          [GWh]"
   eStInterRes   ( p,  g    )  "inter-period storage reserve or SoC          [GWh]"
   eStMaxProd    (rp,k,g    )  "maximum production  considering investment   [GWh]"
   eStMaxCons    (rp,k,g    )  "maximum consumption considering investment   [GWh]"
   eStMaxIntraRes(rp,k,g    )  "maximum storage level considering investment [GWh]"
   eStMinIntraRes(rp,k,g    )  "minimum storage level considering investment [GWh]"
   eStMaxInterRes( p,  g    )  "maximum storage level considering investment [GWh]"
   eStMinInterRes( p,  g    )  "minimum storage level considering investment [GWh]"
   eStProd       (rp,k,g    )  "charge or discharge storage                       "
   eStCons       (rp,k,g    )  "charge or discharge storage                       "
   
$offFold

$onFold // Declaration Renewable Energy Constraints ----------------------------
* renewable energy constraints
   eReMaxProd    (rp,k,g    )  "maximum production considering investment    [GW ]"
   
$offFold

$onFold // Declaration DSM Constraints -----------------------------------------

   eTotalBalance_DSM(rp,  i,sec)  "total balance for DSM                     [GW ]"
   eShift_DSM       (rp,k,i,sec)  "relation DSM up and down                  [GW ]"
   eUB_DSM          (rp,k,i,sec)  "upper bound on hourly DSM                 [GW ]"
   eMaxUp_DSM       (rp,k,i,sec)  "maximum up shifting for DSM               [GW ]"
   eMaxDn_DSM       (rp,k,i,sec)  "maximum down shifting for DSM             [GW ]"
   
$offFold

$onFold // Declaration Zonal Priciging Constraints -----------------------------

$ifThenE.ZonalPricing (%pEnableZP%=1)
   eZP_BalanceP   (rp,k,z  )   "load generation balance for zone             [GW ]"
   eZP_NTC_Exp    (rp,k,z,y)   "max NTC between zones                        [GW ]"
   eZP_NTC_Imp    (rp,k,z,y)   "max NTC between zones                        [GW ]"
   eZP_ExpImp     (rp,k,z,y)   "export equals import from other zone         [GW ]"
$endIf.ZonalPricing
$offFold

$onFold // Declaration DC Power Flow Constraints -------------------------------

   eDC_BalanceP   (rp,k,i    )  "load generation balance per node                  [GW ]"
   eDC_ExiLinePij (rp,k,i,i,c)  "existing  lines DC power flow                     [GW ]"
   eDC_CanLinePij1(rp,k,i,i,c)  "candidate lines DC power flow                     [GW ]"
   eDC_CanLinePij2(rp,k,i,i,c)  "candidate lines DC power flow                     [GW ]"
   eDC_LimCanLine1(rp,k,i,i,c)  "candidate lines DC power flow                     [GW ]"
   eDC_LimCanLine2(rp,k,i,i,c)  "candidate lines DC power flow                     [GW ]"
   eSoftLineLoadLimitPos   (rp,k,i,i,c)  "postive  soft limit for line load existing  lines [GW ]"
   eSoftLineLoadLimitNeg   (rp,k,i,i,c)  "negative soft limit for line load existing  lines [GW ]"
   eSoftLineLoadLimitCanPos(rp,k,i,i,c)  "postive  soft limit for line load candidate lines [GW ]"
   eSoftLineLoadLimitCanNeg(rp,k,i,i,c)  "negative soft limit for line load candidate lines [GW ]"
   eSoftLineLoadLimitCanInv(rp,k,i,i,c)  "              limit for slack var candidate lines [GW ]"
   
$offFold

$onFold // Declaration Second Order Cone Programming (SOCP) Constraints --------

   eSOCP_QMaxOut          (rp,k,g    )  "max Reactive Power output of thermal unit    [Gvar]  "
   eSOCP_QMinOut1         (rp,k,g    )  "min Reactive Power output of thermal unit    [Gvar]  "
   eSOCP_QMinOut2         (rp,k,g    )  "min Reactive Power output of thermal unit    [Gvar]  "
   eSOCP_QMaxFACTS        (rp,k,g    )  "max Reactive Power output of facts   unit    [Gvar]  "
   eSOCP_QMinFACTS        (rp,k,g    )  "min Reactive Power output of facts   unit    [Gvar]  "
   eSOCP_BalanceP         (rp,k,i    )  "balance of real     power for bus            [GW]    "
   eSOCP_BalanceQ         (rp,k,i    )  "balance of reactive power for bus            [Gvar]  "
   eSOCP_ExiLinePij       (rp,k,i,i,c)  "existing line real     power flow            [GW]    "
   eSOCP_ExiLinePji       (rp,k,i,i,c)  "existing line real     power flow            [GW]    "
   eSOCP_ExiLineQij       (rp,k,i,i,c)  "existing line reactive power flow            [GW]    "
   eSOCP_ExiLineQji       (rp,k,i,i,c)  "existing line reactive power flow            [GW]    "
   eSOCP_CanLinePij1      (rp,k,i,i,c)  "candidate line real     power flow           [GW]    "
   eSOCP_CanLinePij2      (rp,k,i,i,c)  "candidate line real     power flow           [GW]    "
   eSOCP_CanLinePji1      (rp,k,i,i,c)  "candidate line real     power flow           [GW]    "
   eSOCP_CanLinePji2      (rp,k,i,i,c)  "candidate line real     power flow           [GW]    "
   eSOCP_CanLineQij1      (rp,k,i,i,c)  "candidate line reactive power flow           [GW]    "
   eSOCP_CanLineQij2      (rp,k,i,i,c)  "candidate line reactive power flow           [GW]    "
   eSOCP_CanLineQji1      (rp,k,i,i,c)  "candidate line reactive power flow           [GW]    "
   eSOCP_CanLineQji2      (rp,k,i,i,c)  "candidate line reactive power flow           [GW]    "
   eSOCP_LimCanLinePij1   (rp,k,i,i,c)  "limit of candidate line real     power flow  [GW]    "
   eSOCP_LimCanLinePij2   (rp,k,i,i,c)  "limit of candidate line real     power flow  [GW]    "
   eSOCP_LimCanLinePji1   (rp,k,i,i,c)  "limit of candidate line real     power flow  [GW]    "
   eSOCP_LimCanLinePji2   (rp,k,i,i,c)  "limit of candidate line real     power flow  [GW]    "
   eSOCP_LimCanLineQij1   (rp,k,i,i,c)  "limit of candidate line reactive power flow  [GW]    "
   eSOCP_LimCanLineQij2   (rp,k,i,i,c)  "limit of candidate line reactive power flow  [GW]    "
   eSOCP_LimCanLineQji1   (rp,k,i,i,c)  "limit of candidate line reactive power flow  [GW]    "
   eSOCP_LimCanLineQji2   (rp,k,i,i,c)  "limit of candidate line reactive power flow  [GW]    "
   eSOCP_ExiLine          (rp,k,i,i  )  "SOCP constraint for auxiliary variables      [GW]    "
   eSOCP_CanLine          (rp,k,i,i  )  "SOCP constraint for auxiliary variables      [GW]    "
   eSOCP_CanLine_cij      (rp,k,i,i  )  "SOCP constraint for auxiliary variables      [GW]    "
   eSOCP_CanLine_sij1     (rp,k,i,i  )  "SOCP constraint for auxiliary variables      [GW]    "
   eSOCP_CanLine_sij2     (rp,k,i,i  )  "SOCP constraint for auxiliary variables      [GW]    "
   eSOCP_IndicConnecNodes1(     i,i  )  "connection between nodes                             "
   eSOCP_IndicConnecNodes2(     i,i  )  "connection between nodes                             "
   eSOCP_CanLineCijUpLim  (rp,k,i,j  )  "Limits to SOCP variables for candidate lines [p.u.]  "
   eSOCP_CanLineCijLoLim  (rp,k,i,j  )  "Limits to SOCP variables for candidate lines [p.u.]  "
   eSOCP_CanLineSijUpLim  (rp,k,i,j  )  "Limits to SOCP variables for candidate lines [p.u.]  "
   eSOCP_CanLineSijLoLim  (rp,k,i,j  )  "Limits to SOCP variables for candidate lines [p.u.]  "
   eSOCP_ExiLineAngDif1   (rp,k,i,i  )  "limit on angle difference                    [p.u.]^2"
   eSOCP_ExiLineAngDif2   (rp,k,i,i  )  "limit on angle difference                    [p.u.]^2"
   eSOCP_CanLineAngDif1   (rp,k,i,i  )  "limit on angle difference                    [p.u.]^2"
   eSOCP_CanLineAngDif2   (rp,k,i,i  )  "limit on angle difference                    [p.u.]^2"
   eSOCP_ExiLineSLimit    (rp,k,i,j,c)  "line apparent power limit                    [GVA ]  "
   eSOCP_CanLineSLimit    (rp,k,i,j,c)  "line apparent power limit                    [GVA ]  "
   
$offFold

$onFold // Declaration Line Investment Constraints -----------------------------

   eTranInves           (     i,j,c)  "order of circuits investment           [N]     "
   
$offFold

$onFold // Declaration Cycle Depth Stress Function (CDSF) Constraints ----------

   eCDSF_ch       (rp,k,g    )  "   charge    for Cycle Depth Stress Function [GW  ]  "
   eCDSF_dis      (rp,k,g    )  "discharge    for Cycle Depth Stress Function [GW  ]  "
   eCDSF_e        (rp,k,g    )  "Tot. energy  for Cycle Depth Stress Function [GW  ]  "
   eCDSF_SoC      (rp,k,g,a  )  "SoC  balance for Cycle Depth Stress Function [GWh ]  "
   eCDSF_MaxSoC   (rp,k,g,a  )  "Max energy   for Cycle Depth Stress Function [GWh ]  "
   eCDSF_EndSoC   (rp,k,g    )  "End energy   for Cycle Depth Stress Function [GWh ]  "
   
$offFold

$onFold // Declaration Rate of Change of Frequency (RoCoF) Constraints ---------

   eRoCoF_ThEq1   (rp,k,  g  )  "linear equation for RoCoF including investment       "
   eRoCoF_ThEq2   (rp,k,g,g  )  "linear equation for RoCoF including investment       "
   eRoCoF_ThEq3   (rp,k,g,g  )  "linear equation for RoCoF including investment       "
   eRoCoF_ThEq4   (rp,k,g,g  )  "linear equation for RoCoF including investment       "
   eRoCoF_ThEq5   (rp,k,g    )  "linear equation for RoCoF including investment       "
   eRoCoF_ThEq6   (rp,k,g    )  "linear equation for RoCoF including investment       "
   eRoCoF_ThEq7   (rp,k,g    )  "linear equation for RoCoF including investment       "
   eRoCoF_ThEq8   (rp,k,g    )  "linear equation for RoCoF including investment       "
   eRoCoF_ThEq9   (rp,k,g    )  "linear equation for RoCoF including investment       "
   eRoCoF_ThEq10  (rp,k,g    )  "linear equation for RoCoF including investment       "
   eRoCoF_ThEq11  (rp,k,g    )  "linear equation for RoCoF including investment       "
   eRoCoF_VgEq1   (rp,k,  g  )  "linear equation for RoCoF including investment       "
   eRoCoF_VgEq2   (rp,k,g,g,m)  "linear equation for RoCoF including investment       "
   eRoCoF_VgEq3   (rp,k,g,g,m)  "linear equation for RoCoF including investment       "
   eRoCoF_VgEq4   (rp,k,g,g,m)  "linear equation for RoCoF including investment       "
   eRoCoF_VgEq5   (rp,k,g  ,m)  "linear equation for RoCoF including investment       "
   eRoCoF_VgEq6   (rp,k,g  ,m)  "linear equation for RoCoF including investment       "
   eRoCoF_VgEq7   (rp,k,g  ,m)  "linear equation for RoCoF including investment       "
   eRoCoF_VgEq8   (     g    )  "linear equation for RoCoF including investment       "
   eRoCoF_VgEq9   (rp,k,g  ,m)  "linear equation for RoCoF including investment       "
   eRoCoF_VgEq10  (rp,k,g  ,m)  "linear equation for RoCoF including investment       "
   eRoCoF_VgEq11  (rp,k,g  ,m)  "linear equation for RoCoF including investment       "
   eRoCoF_SyEq1   (rp,k      )  "linear equation for RoCoF including investment       "
   eRoCoF_SyEq2   (rp,k      )  "linear equation for RoCoF including investment       "
   eRoCoF_SyEq3   (rp,k      )  "linear equation for RoCoF including investment       "
   eRoCoF_SyEq4   (rp,k      )  "linear equation for RoCoF including investment       "
   eRoCoF_SyEq5   (rp,k      )  "linear equation for RoCoF including investment       "
   
$offFold

$onFold // Declaration Import and Export Constraints ---------------------------

*   eImport(rp,k,i)              "import on node in countries not within system        "
*   eExport(rp,k,i)              "export on node in countries not within system        "
*   eLineImport(rp,k,i)          "import must be bigger than zero                      "
*   eLineExport(rp,k,i)          "export must be smaller than zero                     "
*   eLineZero  (rp,k,i,i,c)      "set power flow to zero if import and export are zero "

$offFold

$onFold // Declaration Demand and Production per Zone Constraints --------------

   eZPumpDemand(z)              "minimum consumption of storage units per zone        "
   eZMinSolar  (z)              "minimum production  of solar         per zone        "
   eZMinWind   (z)              "minimum production  of wind          per zone        "               
   eZMinBio    (z)              "minimum production  of biomass       per zone        "
   eZMinWater  (z)              "minimum production  of Hydro+RoR     per zone        "
   eZMaxGas    (z)              "maximum consumtion  of gas           per zone        "
   
$offFold

$onFold // Declaration CO2 Constraints -----------------------------------------

   eCO2_Budget                  "CO2 Budget constraint                       [MtCO2]  "
   
$offFold

$onFold // Declaration Ex-post Calculation of Voltage Angles in SOCP -----------

   eDummyOf                     "Dummy objective function                             "
   eDummyAngDiff  (rp,k,i,j  )  "Dummy equation for voltage angle difference [rad]    "
   
$offFold

$endIf.DeclarationsPower

$ifThenE.DeclarationsH2 (%pEnableH2%=1) // Declaration H2 Sector Constraints --
*  equations for hydrogen
   eH2_MaxProd    (rp,k,h2u      ) "H2 production limit of hydrogen unit     [t    ]  "
   eH2_MaxCons    (rp,k,h2u      ) "H2 cosumption limit of hydrogen unit     [GW   ]  "
   eH2_Convers    (rp,k,h2u      ) "conversion from energy to H2             [t    ]  "
   eH2_Balance    (rp,k,h2i,h2sec) "H2 balance at each hydrogen node         [t    ]  "
$endIf.DeclarationsH2

;


*-------------------------------------------------------------------------------
*                          Mathematical Formulation
*-------------------------------------------------------------------------------
$onFold // Objective Function --------------------------------------------------

eTotalVCost..
   vTotalVCost =e=
* operational costs
   + sum[(rpk(rp,k),i        ), pWeight_rp(rp)*pWeight_k(k)*pENSCost             * vPNS     (rp,k,i)    ]
   + sum[(rpk(rp,k),i        ), pWeight_rp(rp)*pWeight_k(k)*pENSCost*2           * vEPS     (rp,k,i)    ]
   + sum[(rpk(rp,k),z        ), pWeight_rp(rp)*pWeight_k(k)*pENSCost             * vPNSZ    (rp,k,z)    ]$[pEnableZP]
   + sum[(rpk(rp,k),z        ), pWeight_rp(rp)*pWeight_k(k)*pENSCost*2           * vEPSZ    (rp,k,z)    ]$[pEnableZP]
   + sum[(rpk(rp,k),i,seg    ), pWeight_rp(rp)*pWeight_k(k)*pDSMShedCost(seg)    * vDSM_Shed(rp,k,i,seg)]
   + sum[(rpk(rp,k),i,sec    ), pWeight_rp(rp)*pWeight_k(k)*pDSMShiftCost(rp,k,i)* vDSM_Dn  (rp,k,i,sec)]
   + sum[(rpk(rp,k),s        ), pWeight_rp(rp)*pWeight_k(k)*pENSCost/2           *[vSpillag (rp,k,s)+vWaterSell(rp,k,s)$[pRegretCalc]]]
   + sum[(rpk(rp,k),t        ), pWeight_rp(rp)*pWeight_k(k)*pStartupCost (t)     * vStartup (rp,k,t)    ]
   + sum[(rpk(rp,k),t        ), pWeight_rp(rp)*pWeight_k(k)*pInterVarCost(t)     * vCommit  (rp,k,t)    ]
   + sum[(rpk(rp,k),t        ), pWeight_rp(rp)*pWeight_k(k)*pSlopeVarCost(t)     * vGenP    (rp,k,t)    ]
   + sum[(rpk(rp,k),s        ), pWeight_rp(rp)*pWeight_k(k)*pOMVarCost   (s)     * vGenP    (rp,k,s)    ]
   + sum[(rpk(rp,k),r        ), pWeight_rp(rp)*pWeight_k(k)*pOMVarCost   (r)     * vGenP    (rp,k,r)    ]
* CO2 operational costs   
   +                                                                             pCO2Penalty          * vCO2Overshoot             $[pEnableCO2]
   + sum[(rpk(rp,k),t        ), pWeight_rp(rp)*pWeight_k(k)*pCO2Cost*pCO2Emis(t)*pStartupCons     (t) * vStartup      (rp,k,t  )] $[pEnableCO2]
   + sum[(rpk(rp,k),t        ), pWeight_rp(rp)*pWeight_k(k)*pCO2Cost*pCO2Emis(t)*pInterVarCons    (t) * vCommit       (rp,k,t  )] $[pEnableCO2]
   + sum[(rpk(rp,k),t        ), pWeight_rp(rp)*pWeight_k(k)*pCO2Cost*pCO2Emis(t)*pSlopeVarFuelCons(t) * vGenP         (rp,k,t  )] $[pEnableCO2]
* hydrogen operational costs
$ifThenE.H2 (%pEnableH2%=1)
   + sum[           h2u       ,                             pH2OMVarCost (h2u)   * vH2Invest(     h2u      )] $[pEnableH2]
   + sum[(rpk(rp,k),h2i,h2sec), pWeight_rp(rp)*pWeight_k(k)*pH2NSCost            * vH2NS    (rp,k,h2i,h2sec)] $[pEnableH2]
* hydrogen investment costs
   + sum[h2u                  ,                             pH2InvestCost(h2u)   * vH2Invest(     h2u      )] $[pEnableH2]
$endIf.H2
* cycle aging costs
   + sum[(rpk(rp,k),s,a)$[cdsf(s)],
                        pWeight_rp(rp)*pWeight_k(k)*pCDSF_Cost(s,a)  * vCDSF_dis(rp,k,s,a)]
* reserve costs
   + sum[(rpk(rp,k),t), pWeight_rp(rp)*pWeight_k(k)*pSlopeVarCost(t) *
                                                    p2ndResUpCost    * v2ndResUP(rp,k,t)]
   + sum[(rpk(rp,k),t), pWeight_rp(rp)*pWeight_k(k)*pSlopeVarCost(t) *
                                                    p2ndResDwCost    * v2ndResDW(rp,k,t)]
   + sum[(rpk(rp,k),s), pWeight_rp(rp)*pWeight_k(k)*pOMVarCost   (s) *
                                                    p2ndResUpCost    * v2ndResUP(rp,k,s)]
   + sum[(rpk(rp,k),s), pWeight_rp(rp)*pWeight_k(k)*pOMVarCost   (s) *
                                                    p2ndResDwCost    * v2ndResDW(rp,k,s)]
* generation   investment costs
   + sum[ga(g    ), pInvestCost  (g    )* vGenInvest (g    )]
* transmission investment costs
   + sum[lc(i,j,c), pFixedCost   (i,j,c)* vLineInvest(i,j,c)]
* import costs
*  + sum[(rp,k,lbz(j,i,c))            ,                                                    vLineP(rp,k,j,i,c) * pPriceImpExp(rp,k,i)$[pMaxExport(rp,k,i) > 0]]
*   - sum[(rpk(rp,k),i,j,c)$[lbz (i,j,c) and rpkexp(rp,k,j)], pWeight_rp(rp)*pWeight_k(k) * vLineP(rp,k,i,j,c) * pPriceImpExp(rp,k,j)       ]
* export revenue
*  - sum[(rp,k,lbz(j,i,c))            ,                                                    vLineP(rp,k,j,i,c) * pPriceImpExp(rp,k,i)$[pMaxImport(rp,k,i) > 0]]
*   - sum[(rpk(rp,k),i,j,c)$[lbz (i,j,c) and rpkimp(rp,k,j)], pWeight_rp(rp)*pWeight_k(k) * vLineP(rp,k,i,j,c) * pPriceImpExp(rp,k,j)]
* virtual cost for exceeding maximum power line loading
   + sum[(rpk(rp,k),i,j,c) $[isLe(i,j) or isLc(i,j)], pWeight_rp(rp)*pWeight_k(k)*vLineOverload(rp,k,i,j,c)*pLOLCost] $[pEnableMaxLineLoad]
* virtual cost for exporting to minimize ring flows
$ifThenE.ZonalPricing (%pEnablePower%=1)and(%pEnableZP%=1)
   + sum[(rpk(rp,k),NTCe(z,y)), vExpZP(rp,k,z,y)*pWeight_rp(rp)*pWeight_k(k) * pNTCCost] $[pEnableZP]
$endIf.ZonalPricing
;


$offFold

$ifThenE.FormulationsPower (%pEnablePower%=1) // Formulation Power Sector Constraints

$onFold // Formulation Single Node Constraints ---------------------------------

eSN_BalanceP(rpk(rp,k),iact(i))$[not pEnableTransNet]..
   + sum[gi (t,j)   , vGenP     (rp,k,t)]
   + sum[gi (r,j)   , vGenP     (rp,k,r)]
   + sum[gi (s,j)   , vGenP     (rp,k,s)]
   - sum[gi (s,j)   , vConsump  (rp,k,s)]
   +                  vPNS      (rp,k,i)
   + sum[     seg   , vDSM_Shed (rp,k,i,seg)] $[pEnableDSMPower]
   + sum[     sec   , vDSM_Dn   (rp,k,i,sec)] $[pEnableDSMPower]
  =e=
   + sum[      j    , pDemandP  (rp,k,j)]
   +                  vEPS      (rp,k,i)
   + sum[     sec   , vDSM_Up   (rp,k,i,sec)] $[pEnableDSMPower]
$ifThenE.H2 (%pEnableH2%=1)
   + sum[h2gi(h2g,i), vH2Consump(rp,k,h2g  )] $[pEnableH2      ]
$endIf.H2
;

e2ReserveUp(rpk(rp,k))$[p2ndResUp].. sum[t, v2ndResUP(rp,k,t) * max(pExisUnits(t), tThermalGen(t,'EnableInvest'))] + sum[s, v2ndResUP(rp,k,s)] =g= p2ndResUp * sum[i, pDemandP(rp,k,i)] ;
e2ReserveDw(rpk(rp,k))$[p2ndResDw].. sum[t, v2ndResDW(rp,k,t) * max(pExisUnits(t), tThermalGen(t,'EnableInvest'))] + sum[s, v2ndResDW(rp,k,s)] =g= p2ndResDw * sum[i, pDemandP(rp,k,i)] ;

eSoftLineLoadLimitPos   (rpk(rp,k),le(i,j,c))$[pEnableMaxLineLoad].. vLineP(rp,k,i,j,c) =l=  pPmax(i,j,c)       * pMaxLineLoad + vLineOverload(rp,k,i,j,c) * pPmax(i,j,c);
eSoftLineLoadLimitNeg   (rpk(rp,k),le(i,j,c))$[pEnableMaxLineLoad].. vLineP(rp,k,i,j,c) =g= -pPmax(i,j,c)       * pMaxLineLoad - vLineOverload(rp,k,i,j,c) * pPmax(i,j,c);

eSoftLineLoadLimitCanPos(rpk(rp,k),lc(i,j,c))$[pEnableMaxLineLoad].. vLineP(rp,k,i,j,c) =l=  pPmax(i,j,c)       * pMaxLineLoad * vLineInvest(i,j,c) + vLineOverload(rp,k,i,j,c) * pPmax(i,j,c);
eSoftLineLoadLimitCanNeg(rpk(rp,k),lc(i,j,c))$[pEnableMaxLineLoad].. vLineP(rp,k,i,j,c) =g= -pPmax(i,j,c)       * pMaxLineLoad * vLineInvest(i,j,c) - vLineOverload(rp,k,i,j,c) * pPmax(i,j,c);
eSoftLineLoadLimitCanInv(rpk(rp,k),lc(i,j,c))$[pEnableMaxLineLoad].. vLineInvest(i,j,c) =g=  vLineOverload(rp,k,i,j,c) / (1 - pMaxLineLoad);

$offFold

$onFold // Formulation Zonal Balance Constraints -------------------------------
$ifThenE.EnableZP(%pEnableZP%=1)
* This constraint fixes the balance in each zone including exports and imports.
* Supply + imports - exports must meet demand --> in each zone.


eZP_BalanceP(rpk(rp,k),za(z))$[pEnablePower and pEnableZP]..
*  Generation
   + sum[  gz(t,z), vGenP    (rp,k,t  )]
   + sum[  gz(r,z), vGenP    (rp,k,r  )]
   + sum[  gz(s,z), vGenP    (rp,k,s  )]
*  Consumption of power plants        
   - sum[  gz(s,z), vConsump (rp,k,s  )]
*  Export to other zones
   - sum[NTCe(z,y), vExpZP   (rp,k,z,y)$(ord(z) ne ord(y))]
* Import from other zones
   + sum[NTCe(y,z), vImpZP   (rp,k,z,y)$(ord(z) ne ord(y))] 
*  Defined export from node not within system (which is an import to zone)
   + sum[iz(i,z), sum((j,c)$inws(j), lbz(i,j,c)*pMaxExport(rp,k,j) + lbz(j,i,c)*pMaxExport(rp,k,j))]
*  Defined import from node not within system (which is an export from zone)
   - sum(iz(i,z), sum((j,c)$inws(j), lbz(i,j,c)*pMaxImport(rp,k,j) + lbz(j,i,c)*pMaxImport(rp,k,j)))
*  Demand for hydorgen production
   + sum[iz(i,z), sum(h2gi(h2g,i)  , vH2Consump(rp,k,h2g  ))] $[pEnableH2 ]
*  Power not served in zone
   +                vPNSZ    (rp,k,z  )
  =e=
*  Demand in zone
   + sum[iz(i,z), pDemandP   (rp,k,i  )]
*  Excess Power in zone
   +                vEPSZ    (rp,k,z  )
;


* Export must be smaller than NTC between zone A und B
eZP_NTC_Exp(rpk(rp,k),NTCe(z,y))$[pEnablePower and pEnableZP]..
*   + vExpZP(rp,k,z,y) - vImpZP(rp,k,z,y))$(ord(z) ne ord(y))
   + vExpZP(rp,k,z,y)
  =l=
   + pNTC(z,y)*vBinExpNTC(rp,k,z,y)
;


* Import must be smaller than NTC between zone B and A
* Import not allowed if there is already an export
eZP_NTC_Imp(rpk(rp,k),NTCe(z,y))$[pEnablePower and pEnableZP]..
*   + (vExpZP(rp,k,z,y) - vImpZP(rp,k,z,y))$(ord(z) ne ord(y))
   + vImpZP(rp,k,z,y)
  =l=
   + pNTC(y,z) * (1-vBinExpNTC(rp,k,z,y) )
;


* Export from zone A to zone B has to be import of zone B from zone A
eZP_ExpImp(rpk(rp,k),NTCe(z,y))$[pEnablePower and pEnableZP]..
   + (vExpZP(rp,k,z,y) - vImpZP(rp,k,y,z)) $(ord(z) ne ord(y))
  =e=
   + 0
;
$endIf.EnableZP
$offFold

$onFold // Formulation DSM Constraints -----------------------------------------

eTotalBalance_DSM(rp,iact(i),sec)$[pEnableDSMPower] ..
                       + sum[k$[rpk(rp,k)], vDSM_Up(rp,k,i,sec)]
                       - sum[k$[rpk(rp,k)], vDSM_Dn(rp,k,i,sec)]
                       =e= 0;

eShift_DSM(rpk(rp,k),iact(i),sec)  $[pEnableDSMPower] .. vDSM_Up(rp,k,i,sec) =l= sum[kk $[dsm(rp,k,kk,sec)], vDSM_Dn(rp,kk,i,sec)];

eUB_DSM   (rpk(rp,k),iact(i),sec)  $[pEnableDSMPower] .. vDSM_Up(rp,k,i,sec) + vDSM_Dn(rp,k,i,sec)  =l=
                                                 +       max(pMaxUpDSM(rp,k,i,sec), pMaxDnDSM(rp,k,i,sec))  $[    pEnableTransNet]
                                                 + sum[j,max(pMaxUpDSM(rp,k,j,sec), pMaxDnDSM(rp,k,j,sec))] $[not pEnableTransNet];

eMaxUp_DSM (rpk(rp,k),iact(i),sec) $[pEnableDSMPower] .. vDSM_Up(rp,k,i,sec) =l= pMaxUpDSM (rp,k,i,sec);

eMaxDn_DSM (rpk(rp,k),iact(i),sec) $[pEnableDSMPower] .. vDSM_Dn(rp,k,i,sec) =l= pMaxDnDSM (rp,k,i,sec);

$offFold

$onFold // Formulation Unit Commitment Constraints -----------------------------

eUCMaxOut1(rpk(rp,k),t)..
   + vGenP1   (rp,k,t)
   + v2ndResUP(rp,k,t)
  =l=
   + [pMaxProd(t)-pMinProd(t)] * [vCommit (rp,k,t)
                                 -vStartup(rp,k,t)]
;

eUCMaxOut2(rpk(rp,k),t)..
   + vGenP1   (rp,k,t)
   + v2ndResUP(rp,k,t)
  =l=
   + [pMaxProd(t)-pMinProd(t)] * [vCommit  (rp,k   ,t)
                                 -vShutdown(rp,k++1,t)]
;

eUCMinOut (rpk(rp,k),t)..
   + vGenP1   (rp,k,t)
   - v2ndResDW(rp,k,t)
  =g=
   0
;

eUCTotOut(rpk(rp,k),t)..
   + vGenP   (rp,k,t)
  =e=
   + vCommit (rp,k,t) * pMinProd(t)
   + vGenP1  (rp,k,t)
;

eUCStrShut(rpk(rp,k)  ,t)..
   + vCommit  (rp,k   ,t)
   - vCommit  (rp,k--1,t)
  =e=
   + vStartup (rp,k   ,t)
   - vShutdown(rp,k   ,t)
;

eThRampUp (rpk(rp,k)  ,t)..
   + vGenP1   (rp,k   ,t)
   - vGenP1   (rp,k--1,t)
   + v2ndResUP(rp,k   ,t)
  =l=
   + vCommit  (rp,k   ,t) *  pRampUp (t)
;

eThRampDw (rpk(rp,k)  ,t)..
   + vGenP1   (rp,k   ,t)
   - vGenP1   (rp,k--1,t)
   - v2ndResDW(rp,k   ,t)
  =g=
   - vCommit  (rp,k--1,t) *  pRampDw (t)
;

eThMaxUC  (rpk(rp,k)  ,t)..
   + vCommit  (rp,k   ,t) =l= vGenInvest(t) + pExisUnits(t) ;

$offFold

$onFold // Formulation Energy Storage Constraints ------------------------------

eStIntraRes(rpk(rp,k),   s) $[[card(rp)=1] or [card(rp)>1 and not hydro(s)] and not cdsf(s)]..
   + vStIntraRes(rp,k--1,s) $[ card(rp)>1             ]
   + vStIntraRes(rp,k- 1,s) $[ card(rp)=1             ]
   + pIniReserve(        s) $[ card(rp)=1 and ord(k)=1]
   - vStIntraRes(rp,k   ,s)
   - vSpillag   (rp,k   ,s)                $[pIsHydro (s)]
   + pInflows   (rp,k   ,s)                $[pIsHydro (s)]
   - vGenP      (rp,k   ,s) * pWeight_k(k) / pDisEffic(s)
   + vConsump   (rp,k   ,s) * pWeight_k(k) * pChEffic (s)
   + vWaterSell (rp,k   ,s) $[pRegretCalc and pIsHydro(s)]
  =e=
   0
;

eStInterRes     (p           ,s) $[[card(rp)>1] and [mod(ord(p),pMovWindow)=0]]..
   + vStInterRes(p-pMovWindow,s)
   + pIniReserve(             s) $[ord(p)=pMovWindow]
   - vStInterRes(p           ,s)
   + sum[hindex(pp,rpk(rp,k))$[[ord(pp)>  ord(p)-pMovWindow] and
                              [ ord(pp)<= ord(p)         ]],
        - vSpillag (rp,k,s)                $[pIsHydro (s)]
        + pInflows (rp,k,s)                $[pIsHydro (s)]
        - vGenP    (rp,k,s) * pWeight_k(k) / pDisEffic(s)
        + vConsump (rp,k,s) * pWeight_k(k) * pChEffic (s)
        ]
  =e=
   0
;

eStMaxProd    (rpk(rp,k),s).. vGenP(rp,k,s) - vConsump(rp,k,s) + v2ndResUP(rp,k,s) =l=  pMaxProd(s)*[vGenInvest(s)+ pExisUnits(s)] ;
eStMaxCons    (rpk(rp,k),s).. vGenP(rp,k,s) - vConsump(rp,k,s) - v2ndResDW(rp,k,s) =g= -pMaxCons(s)*[vGenInvest(s)+ pExisUnits(s)] ;

eStProd       (rpk(rp,k),s)$[pEnableChDisPower].. vGenP(rp,k,s)    =l= [pMaxInvest(s)+pExisUnits(s)]*pMaxProd(s)*   vChDis(rp,k,s) ;
eStCons       (rpk(rp,k),s)$[pEnableChDisPower].. vConsump(rp,k,s) =l= [pMaxInvest(s)+pExisUnits(s)]*pMaxCons(s)*[1-vChDis(rp,k,s)];

eStMaxIntraRes(rpk(rp,k),s).. vStIntraRes(rp,k,s) =l= pMaxProd(s)*[vGenInvest(s)+pExisUnits(s)] * pE2PRatio(s)                  - [v2ndResDW(rp,k,s)+v2ndResDW(rp,k--1,s)] * pWeight_k(k) ;
eStMinIntraRes(rpk(rp,k),s).. vStIntraRes(rp,k,s) =g= pMaxProd(s)*[vGenInvest(s)+pExisUnits(s)] * pE2PRatio(s) * pMinReserve(s) + [v2ndResUP(rp,k,s)+v2ndResUP(rp,k--1,s)] * pWeight_k(k) ;

eStMaxInterRes(p,s)$[mod(ord(p),pMovWindow)=0].. vStInterRes(p,s) =l= pMaxProd(s)*[vGenInvest(s)+pExisUnits(s)] * pE2PRatio(s)                 ;
eStMinInterRes(p,s)$[mod(ord(p),pMovWindow)=0].. vStInterRes(p,s) =g= pMaxProd(s)*[vGenInvest(s)+pExisUnits(s)] * pE2PRatio(s) * pMinReserve(s);

$offFold

$onFold // Formulation Renewable Energy Constraints ----------------------------

eReMaxProd(rpk(rp,k),r)..
   + vGenP(rp,k,r) =l= sum[gi(r,i),[pMaxProd(r)*[vGenInvest(r)+pExisUnits(r)]]*pResProfile(rp,k,i,r)]
;

eCleanProdLimThermal$[pMinGreenProd and not pEnableGreenNatBal]..
   + sum[rpk(rp,k),pWeight_rp(rp)*pWeight_k(k)*sum[gi(t,j), vGenP   (rp,k,t)]]   
  =l=
   + [1-pMinGreenProd]
   * sum[rpk(rp,k),pWeight_rp(rp)*pWeight_k(k)*sum[     j , pDemandP(rp,k,j)]]
;

eCleanProdNatBal$[pMinGreenProd and pEnableGreenNatBal]..
   + sum[rpk(rp,k),pWeight_rp(rp)*pWeight_k(k)*sum[gi(b,j)  , vGenP   (rp,k,b  )]]
   + sum[rpk(rp,k),pWeight_rp(rp)*pWeight_k(k)*sum[gi(s,j)  , vGenP   (rp,k,s  )]]
   + sum[rpk(rp,k),pWeight_rp(rp)*pWeight_k(k)*sum[gi(r,j)  , vGenP   (rp,k,r  )]]
   - sum[rpk(rp,k),pWeight_rp(rp)*pWeight_k(k)*sum[gi(s,j)  , vConsump(rp,k,s  )]]
  =g=
   + pMinGreenProd
   * sum[rpk(rp,k),pWeight_rp(rp)*pWeight_k(k)*sum[     j   , pDemandP(rp,k,j  )]]
;

$offFold

$onFold // Formulation Firm Supply Constraints ---------------------------------

eFirmCapCon$[pMinFirmCap]..
   + sum[g$ga(g), pFirmCapCoef(g)*pMaxProd(g)*[vGenInvest(g)+pExisUnits(g)]]
   =g= pMinFirmCap*pPeakDemand
;

$offFold

$onFold // Formulation Rate of Change of Frequency (RoCoF) Constraints ---------

* default constraints when we are not using RoCoF contraints
eMinInertia(rpk(rp,k))$[not pEnableRoCoF and pMinInertia].. sum[t, vCommit(rp,k,t)*pInertiaConst(t)] =g= pMinInertia ;

* Linear constraints to consider RoCoF inertia constraints including investment
eRoCoF_ThEq1 (rpk(rp,k),   t  )$[pEnableRoCoF]..sum[tt,pMaxProd(tt)*vRoCoF_AuxY(rp,k,tt,t)] =e= vCommit    (rp,k,t )* pMaxProd(t)                ;
eRoCoF_ThEq2 (rpk(rp,k),tt,t  )$[pEnableRoCoF]..                    vRoCoF_AuxY(rp,k,tt,t)  =l= vCommit    (rp,k,tt)                             ;
eRoCoF_ThEq3 (rpk(rp,k),tt,t  )$[pEnableRoCoF]..                    vRoCoF_AuxY(rp,k,tt,t)  =l= vRoCoF_k   (rp,k,t )                             ;
eRoCoF_ThEq4 (rpk(rp,k),tt,t  )$[pEnableRoCoF]..                    vRoCoF_AuxY(rp,k,tt,t)  =g= vRoCoF_k   (rp,k,t )-       [1-vCommit(rp,k,tt)] ;
eRoCoF_ThEq5 (rpk(rp,k),tt    )$[pEnableRoCoF]..                    vRoCoF_AuxZ(rp,k,tt  )  =l= vCommit    (rp,k,tt)*pUBLin                      ;
eRoCoF_ThEq6 (rpk(rp,k),tt    )$[pEnableRoCoF]..                    vRoCoF_AuxZ(rp,k,tt  )  =l= vRoCoF_SG_M(rp,k   )                             ;
eRoCoF_ThEq7 (rpk(rp,k),tt    )$[pEnableRoCoF]..                    vRoCoF_AuxZ(rp,k,tt  )  =g= vRoCoF_SG_M(rp,k   )-pUBLin*[1-vCommit(rp,k,tt)] ;
eRoCoF_ThEq8 (rpk(rp,k),tt    )$[pEnableRoCoF]..                    vRoCoF_k   (rp,k,tt  )  =l= vCommit    (rp,k,tt)                             ;
eRoCoF_ThEq9 (rpk(rp,k),tt    )$[pEnableRoCoF]..               vRoCoF_SysM_AuxZ(rp,k,tt  )  =l= vCommit    (rp,k,tt)*pUBLin                      ;
eRoCoF_ThEq10(rpk(rp,k),tt    )$[pEnableRoCoF]..               vRoCoF_SysM_AuxZ(rp,k,tt  )  =l= vRoCoF_SysM(rp,k   )                             ;
eRoCoF_ThEq11(rpk(rp,k),tt    )$[pEnableRoCoF]..               vRoCoF_SysM_AuxZ(rp,k,tt  )  =g= vRoCoF_SysM(rp,k   )-pUBLin*[1-vCommit(rp,k,tt)] ;

eRoCoF_VgEq1 (rpk(rp,k),   v  )$[pEnableRoCoF].. vGenP      (rp,k,   v  ) =e= sum[gi(vv,i),[pMaxProd(vv)*[sum[m,2**[ord(m)-1]*vRoCoF_AuxW(rp,k,vv,v,m)]+pExisUnits(vv)*vRoCoF_k(rp,k,v)]]*pResProfile(rp,k,i,vv)] ;
eRoCoF_VgEq2 (rpk(rp,k),vv,v,m)$[pEnableRoCoF].. vRoCoF_AuxW(rp,k,vv,v,m) =l=               vRoCoF_AuxI(vv,m   )                              ;
eRoCoF_VgEq3 (rpk(rp,k),vv,v,m)$[pEnableRoCoF].. vRoCoF_AuxW(rp,k,vv,v,m) =l=               vRoCoF_k   (rp,k,v )                              ;
eRoCoF_VgEq4 (rpk(rp,k),vv,v,m)$[pEnableRoCoF].. vRoCoF_AuxW(rp,k,vv,v,m) =g=               vRoCoF_k   (rp,k,v )-       [1-vRoCoF_AuxI(vv,m)] ;
eRoCoF_VgEq5 (rpk(rp,k),vv,  m)$[pEnableRoCoF].. vRoCoF_AuxV(rp,k,vv,  m) =l=               vRoCoF_AuxI(vv,m   )*pUBLin                       ;
eRoCoF_VgEq6 (rpk(rp,k),vv,  m)$[pEnableRoCoF].. vRoCoF_AuxV(rp,k,vv,  m) =l=               vRoCoF_VI_M(rp,k   )                              ;
eRoCoF_VgEq7 (rpk(rp,k),vv,  m)$[pEnableRoCoF].. vRoCoF_AuxV(rp,k,vv,  m) =g=               vRoCoF_VI_M(rp,k   )-pUBLin*[1-vRoCoF_AuxI(vv,m)] ;
eRoCoF_VgEq8 (             v  )$[pEnableRoCoF].. vGenInvest (        v  ) =e= sum[m       , vRoCoF_AuxI(    v,m)*2**[ord(m)-1]              ] ;
eRoCoF_VgEq9 (rpk(rp,k),vv,  m)$[pEnableRoCoF].. vRoCoF_SysM_AuxV(rp,k,vv,m) =l=            vRoCoF_AuxI(vv,m   )*pUBLin                       ;
eRoCoF_VgEq10(rpk(rp,k),vv,  m)$[pEnableRoCoF].. vRoCoF_SysM_AuxV(rp,k,vv,m) =l=            vRoCoF_SysM(rp,k   )                              ;
eRoCoF_VgEq11(rpk(rp,k),vv,  m)$[pEnableRoCoF].. vRoCoF_SysM_AuxV(rp,k,vv,m) =g=            vRoCoF_SysM(rp,k   )-pUBLin*[1-vRoCoF_AuxI(vv,m)] ;

eRoCoF_SyEq1(rpk(rp,k))$[pEnableRoCoF]..pDeltaP(rp,k)     =l= [pMaxRoCoF/pBaseFreq]*vRoCoF_SysM(rp,k);
eRoCoF_SyEq2(rpk(rp,k))$[pEnableRoCoF]..vRoCoF_SG_M(rp,k) =e= sum[t,2*pInertiaConst(t)*                     vRoCoF_k   (rp,k,t     )] ;
eRoCoF_SyEq3(rpk(rp,k))$[pEnableRoCoF]..vRoCoF_VI_M(rp,k) =e= sum[v,2*pInertiaConst(v)*sum[m, 2**(ord(m)-1)*vRoCoF_AuxW(rp,k,v,v,m)]] ;
eRoCoF_SyEq4(rpk(rp,k))$[pEnableRoCoF]..vRoCoF_SysM(rp,k) =l= pUBLin * [+sum[t          ,pMaxProd(t)*vCommit    (rp,k,t  )                            ]
                                                                        +sum[(gi(v,i),m),pMaxProd(v)*pResProfile(rp,k,i,v)*vGenInvest   (v)*2**[ord(m)-1]]
                                                                        +sum[ gi(v,i)   ,pMaxProd(v)*pResProfile(rp,k,i,v)*pExisUnits(v)              ]
                                                                        ] ;
eRoCoF_SyEq5(rpk(rp,k))$[pEnableRoCoF]..
   +sum[t          ,pMaxProd(t)*vRoCoF_SysM_AuxZ(rp,k,t  )                                    ]
   +sum[(gi(v,i),m),pMaxProd(v)*vRoCoF_SysM_AuxV(rp,k,v,m)*pResProfile(rp,k,i,v)*2**[ord(m)-1]]
   +sum[ gi(v,i)   ,pMaxProd(v)*vRoCoF_SysM     (rp,k    )*pResProfile(rp,k,i,v)*pExisUnits(v)]
  =e=
   +sum[t          ,pMaxProd(t)*vRoCoF_AuxZ     (rp,k,t  )                                    ]
   +sum[(gi(v,i),m),pMaxProd(v)*vRoCoF_AuxV     (rp,k,v,m)*pResProfile(rp,k,i,v)*2**[ord(m)-1]]
   +sum[ gi(v,i)   ,pMaxProd(v)*vRoCoF_VI_M     (rp,k    )*pResProfile(rp,k,i,v)*pExisUnits(v)]
;

$offFold

$onFold // Formulation Import and Export Constraints ---------------------------

* Import on node in countries not within system =g= =e=
*eImport(rp,k,i)$[(rpkimp(rp,k,i) or rpknimpexp(rp,k,i)) and iact(i) and inws(i)]..
*   +pMaxImport(rp,k,i)
*  =e= 
*   +sum[lbz(j,i,c), vLineP(rp,k,j,i,c)]
;
* If import to nodes not within system could be variable    
*   pMaxImport(rp,k,i) =g= sum[lbz(j,i,c), vLineP(rp,k,j,i,c)];


* Import must be bigger than zero
*eLineImport(rp,k,i)$[(rpkimp(rp,k,i) or rpknimpexp(rp,k,i)) and iact(i) and inws(i)]..
*   +sum[lbz(j,i,c), vLineP(rp,k,j,i,c)]
*  =g=
*   +0
*;

* Export on node in countries not within system =l= =e=
*eExport(rp,k,i)$[(rpkexp(rp,k,i) or rpknimpexp(rp,k,i)) and iact(i) and inws(i)]..
*   -pMaxExport(rp,k,i)
*  =e=
*   +sum[lbz(j,i,c), vLineP(rp,k,j,i,c)]
*;

* Export must be smaller than zero
*eLineExport(rp,k,i)$[(rpkexp(rp,k,i) or rpknimpexp(rp,k,i)) and iact(i) and inws(i)]..
*   +sum[lbz(j,i,c), vLineP(rp,k,j,i,c)]
*  =l=
*   +0
*;

*eLineZero(rpk(rp,k),le(j,i,c))$[pMaxImport(rp,k,i)=0 and pMaxExport(rp,k,i)=0 and iact(i)  and inws(i)]..
*   +vLineP(rp,k,j,i,c)
*  =e=
*   0
;

$offFold

$onFold // Formulation Demand and Production per Zone Constraints --------------

eZPumpDemand(z)$[pEnableMinProdRESTech]..
   + sum[rpk(rp,k),pWeight_rp(rp)*pWeight_k(k)*sum[gz(s    ,z)  , vConsump(rp,k,s    )$[pIsHydro (s)]]]
  =g=
   pPumpDemand(z)
;

eZMinSolar(z)$[pEnableMinProdRESTech]..
   + sum[rpk(rp,k),pWeight_rp(rp)*pWeight_k(k)*sum[gz(solar,z)  , vGenP   (rp,k,solar)]]
  =g=
   pMinSolar(z)
;

eZMinWind(z)$[pEnableMinProdRESTech]..
   + sum[rpk(rp,k),pWeight_rp(rp)*pWeight_k(k)*sum[gz(wind ,z)  , vGenP   (rp,k,wind )]]
  =g=
   pMinWind(z)
;

eZMinBio(z)$[pEnableMinProdRESTech]..
   + sum[rpk(rp,k),pWeight_rp(rp)*pWeight_k(k)*sum[gz(b    ,z)  , vGenP   (rp,k,b    )]]
  =g=
   pMinBio(z)
;

eZMinWater(z)$[pEnableMinProdRESTech]..
   + sum[rpk(rp,k),pWeight_rp(rp)*pWeight_k(k)*sum[gz(ror  ,z)  , vGenP   (rp,k,ror  )               ]]
   + sum[rpk(rp,k),pWeight_rp(rp)*pWeight_k(k)*sum[gz(hydro,z)  , vGenP   (rp,k,hydro)               ]]
   - sum[rpk(rp,k),pWeight_rp(rp)*pWeight_k(k)*sum[gz(s    ,z)  , vConsump(rp,k,s    )$[pIsHydro (s)]]]
   =g=
   pMinWater(z)
;

eZMaxGas (z)$[pEnableMaxGas]..
   + sum[rpk(rp,k),pWeight_rp(rp)*pWeight_k(k)*sum[gz(gas  ,z)  , vGenP   (rp,k,gas  )]]
  =l=
   pMaxGas(z)
;

$offFold

$onFold // Formulation Cycle Depth Stress Function (CDSF) Constraints ----------

eCDSF_dis(rpk(rp,k),s)$[cdsf(s)].. vGenP      (rp,k,s) =e= sum[a, vCDSF_dis(rp,k,s,a)] ;
eCDSF_ch (rpk(rp,k),s)$[cdsf(s)].. vConsump   (rp,k,s) =e= sum[a, vCDSF_ch (rp,k,s,a)] ;
eCDSF_e  (rpk(rp,k),s)$[cdsf(s)].. vStIntraRes(rp,k,s) =e= sum[a, vCDSF_SoC(rp,k,s,a)] ;

eCDSF_SoC   (rpk(rp,k),  s,a) $[ cdsf(s )]..
   + vCDSF_SoC  (rp,k--1,s,a) $[ card(rp)>1             ]
   + vCDSF_SoC  (rp,k- 1,s,a) $[ card(rp)=1             ]
   + pIniReserve(        s  ) $[ card(rp)=1 and ord(k)=1]
   - vCDSF_SoC  (rp,k   ,s,a)
   - vCDSF_dis  (rp,k   ,s,a) * pWeight_k(k) / pDisEffic(s)
   + vCDSF_ch   (rp,k   ,s,a) * pWeight_k(k) * pChEffic (s)
  =e=
   0
;

eCDSF_MaxSoC(rpk(rp,k),s,a)$[cdsf(s)].. vCDSF_SoC(rp,k,s,a) =l= pMaxProd(s)*[vGenInvest(s)+pExisUnits(s)]*pE2PRatio(s)/card(a);
eCDSF_EndSoC(rpk(rp,k),s  )$[cdsf(s) and card(rp)=1 and ord(k)=card(k)]..
   + sum[a,vCDSF_SoC(rp,k,s,a)] =g= pIniReserve(s)
;

$offFold

$onFold // Formulation DC Power Flow Constraints -------------------------------

eDC_BalanceP(rpk(rp,k), iws(i))$[pEnableTransNet and not pEnableSOCP and not pEnableZP]..
   + sum[gi(t,i  ),   vGenP     (rp,k,t    )]
   + sum[gi(r,i  ),   vGenP     (rp,k,r    )]
   + sum[gi(s,i  ),   vGenP     (rp,k,s    )]
   - sum[gi(s,i  ),   vConsump  (rp,k,s    )]
   + sum[la(j,i,c),   vLineP    (rp,k,j,i,c)]
   - sum[la(i,j,c),   vLineP    (rp,k,i,j,c)]
   +                  vPNS      (rp,k,i    )
   + sum[      seg,   vDSM_Shed (rp,k,i,seg)] $[pEnableDSMPower]
   + sum[      sec,   vDSM_Dn   (rp,k,i,sec)] $[pEnableDSMPower]
  =e=
   +                  pDemandP  (rp,k,i    )
   +                  vEPS      (rp,k,i    )
   + sum[      sec  , vDSM_Up   (rp,k,i,sec)] $[pEnableDSMPower]
$ifThenE.H2 (%pEnableH2%=1)
   + sum[h2gi(h2g,i), vH2Consump(rp,k,h2g  )] $[pEnableH2 ]
$endIf.H2
;

* power flow existing lines
eDC_ExiLinePij(rpk(rp,k),le(i,j,c)) $[pEnableTransNet and not pEnableSOCP and not pEnableZP]..
   + vLineP(       rp,k ,   i,j,c) =e= [vTheta(rp,k,i)-vTheta(rp,k,j)+vAngle(rp,k,i,j,c)] * pSBase / [pXline(i,j,c)*pRatio(i,j,c)] ;

* power flow candidate lines
eDC_CanLinePij1(rpk(rp,k),lc(i,j,c)) $[pEnableTransNet and not pEnableSOCP and not pEnableZP].. vLineP(rp,k,i,j,c)/ [pBigM_Flow*pPmax(i,j,c)] =g= [vTheta(rp,k,i) - vTheta(rp,k,j)+ vAngle(rp,k,i,j,c)] * pSbase / [pXline(i,j,c)*pRatio(i,j,c)] / [pBigM_Flow*pPmax(i,j,c)] - 1 + vLineInvest(i,j,c) ;
eDC_CanLinePij2(rpk(rp,k),lc(i,j,c)) $[pEnableTransNet and not pEnableSOCP and not pEnableZP].. vLineP(rp,k,i,j,c)/ [pBigM_Flow*pPmax(i,j,c)] =l= [vTheta(rp,k,i) - vTheta(rp,k,j)+ vAngle(rp,k,i,j,c)] * pSbase / [pXline(i,j,c)*pRatio(i,j,c)] / [pBigM_Flow*pPmax(i,j,c)] + 1 - vLineInvest(i,j,c) ;

* power flow limit on candidate lines
eDC_LimCanLine1(rpk(rp,k),lc(i,j,c)) $[pEnableTransNet and not pEnableSOCP and not pEnableZP].. vLineP(rp,k,i,j,c)/             pPmax(i,j,c)  =g=   - vLineInvest(i,j,c) ;
eDC_LimCanLine2(rpk(rp,k),lc(i,j,c)) $[pEnableTransNet and not pEnableSOCP and not pEnableZP].. vLineP(rp,k,i,j,c)/             pPmax(i,j,c)  =l=     vLineInvest(i,j,c) ;

$offFold

$onFold // Formulation Second Order Cone Programming (SOCP) Constraints --------

eSOCP_BalanceP(rpk(rp,k),i) $[pEnableTransNet and pEnableSOCP] ..
   + sum[gi   (t,i), vGenP     (rp,k,t    )]
   + sum[gi   (r,i), vGenP     (rp,k,r    )]
   + sum[gi   (s,i), vGenP     (rp,k,s    )]
   - sum[gi   (s,i), vConsump  (rp,k,s    )]
   +                 vPNS      (rp,k,i    )
   + sum[       seg, vDSM_Shed (rp,k,i,seg)]   $[pEnableDSMPower]
   + sum[       sec, vDSM_Dn   (rp,k,i,sec)]   $[pEnableDSMPower]
*  +                 pMaxExport(rp,k,i    )
  =e=
   + sum[(j,c) $la(i,j,c), vLineP(rp,k,i,j,c    )]
   + sum[(j,c) $la(j,i,c), vLineP(rp,k,i,j,c    )]
   +                       vSOCP_cii (rp,k,i    ) * pBusG(i) * pSBase
   +                       pDemandP  (rp,k,i    )
   +                       vEPS      (rp,k,i    )
   + sum[       sec      , vDSM_Up   (rp,k,i,sec)] $[pEnableDSMPower]
$ifThenE.H2 (%pEnableH2%=1)
   + sum[h2gi(h2g,i)     , vH2Consump(rp,k,h2g  )] $[pEnableH2 ]
$endIf.H2
*   +                      pMaxImport(rp,k,i    )
;

eSOCP_BalanceQ(rpk(rp,k),i) $[pEnableTransNet and pEnableSOCP] ..
   + sum[gi(t    ,i), vGenQ    (rp,k,t    )]
   + sum[gi(r    ,i), vGenQ    (rp,k,r    )]
   + sum[gi(s    ,i), vGenQ    (rp,k,s    )]
   + sum[gi(facts,i), vGenQ    (rp,k,facts)]
   +                  vPNS     (rp,k,i    )  * pRatioDemQP(i)
   + sum[       seg,  vDSM_Shed(rp,k,i,seg)] * pRatioDemQP(i) $[pEnableDSMPower]
   + sum[       sec,  vDSM_Dn  (rp,k,i,sec)] * pRatioDemQP(i) $[pEnableDSMPower]
  =e=
   + sum[(j,c) $la(i,j,c), vLineQ(rp,k,i,j,c    )]
   + sum[(j,c) $la(j,i,c), vLineQ(rp,k,i,j,c    )]
   -                       vSOCP_cii (rp,k,i    )  * pBusB(i) * pSBase
   +                       pDemandQ  (rp,k,i    )
   +                       vEPS      (rp,k,i    )  * pRatioDemQP(i  )
   + sum[       sec      , vDSM_Up   (rp,k,i,sec)] * pRatioDemQP(i  )  $[pEnableDSMPower]
$ifThenE.H2 (%pEnableH2%=1)
   + sum[h2gi(h2g,i)     , vH2Consump(rp,k,h2g  )  * pH2RatioQP (h2g)] $[pEnableH2]
$endIf.H2
;

eSOCP_QMaxOut (rpk(rp,k),t) $[pEnableTransNet and pEnableSOCP and pMaxGenQ(t)  ].. vGenQ(rp,k,t) / pMaxGenQ(t) =l= vCommit(rp,k,t) ;
eSOCP_QMinOut1(rpk(rp,k),t) $[pEnableTransNet and pEnableSOCP and pMinGenQ(t)>0].. vGenQ(rp,k,t) / pMinGenQ(t) =g= vCommit(rp,k,t) ;
eSOCP_QMinOut2(rpk(rp,k),t) $[pEnableTransNet and pEnableSOCP and pMinGenQ(t)<0].. vGenQ(rp,k,t) / pMinGenQ(t) =l= vCommit(rp,k,t) ;

eSOCP_QMaxFACTS(rpk(rp,k),facts) $[pEnableTransNet and pEnableSOCP].. vGenQ(rp,k,facts) =l= pMaxGenQ(facts) * [pExisUnits(facts) + vGenInvest(facts)] ;
eSOCP_QMinFACTS(rpk(rp,k),facts) $[pEnableTransNet and pEnableSOCP].. vGenQ(rp,k,facts) =g= pMinGenQ(facts) * [pExisUnits(facts) + vGenInvest(facts)] ;

* active and reactive power flow on existing lines
eSOCP_ExiLinePij(rpk(rp,k),i,j,c) $[le (i,j,c) and pEnableTransNet and pEnableSOCP]..
  vLineP        (rp,k ,i,j,c)  =e= pSBase * [
      + [   pGline    (     i,j,c)  * [vSOCP_cii(rp,k,i)] / sqr[pRatio(i,j,c)]]
      - [1/ pRatio    (     i,j,c)] *
           [pGline    (     i,j,c)  * cos[pAngle(i,j,c)] - pBline(i,j,c) * sin[pAngle(i,j,c)]] *
           [ vSOCP_cij(rp,k,i,j  )]
      - [1/ pRatio    (     i,j,c)] *
           [pBline    (     i,j,c)  * cos[pAngle(i,j,c)] + pGline(i,j,c) * sin[pAngle(i,j,c)]] *
           [-vSOCP_sij(rp,k,i,j  )] ]
;

eSOCP_ExiLinePji(rpk(rp,k),i,j,c) $[le (i,j,c) and pEnableTransNet and pEnableSOCP]..
   vLineP       (rp,k ,j,i,c) =e= pSBase * [
      + [   pGline    (     i,j,c)  * [vSOCP_cii(rp,k,j)]]
      - [1/ pRatio    (     i,j,c)] *
           [pGline    (     i,j,c)  * cos[pAngle(i,j,c)] + pBline(i,j,c) * sin[pAngle(i,j,c)]] *
           [ vSOCP_cij(rp,k,i,j  )]
      - [1/ pRatio    (     i,j,c)] *
           [pBline    (     i,j,c)  * cos[pAngle(i,j,c)] - pGline(i,j,c) * sin[pAngle(i,j,c)]] *
           [ vSOCP_sij(rp,k,i,j  )] ]
;

eSOCP_ExiLineQij(rpk(rp,k),i,j,c) $[le (i,j,c) and pEnableTransNet and pEnableSOCP]..
   vLineQ       (rp,k ,i,j,c)  =e= pSBase * [
      - [[   vSOCP_cii(rp,k,i    )] * [pBline(i,j,c) + pBcline(i,j,c)/2] / sqr[pRatio(i,j,c)]]
      - [1/  pRatio   (     i,j,c)] *
           [ pGline   (     i,j,c)  * cos[pAngle(i,j,c)] - pBline(i,j,c) * sin[pAngle(i,j,c)]] *
           [-vSOCP_sij(rp,k,i,j  )]
      + [1/  pRatio   (     i,j,c)] *
           [ pBline   (     i,j,c)  * cos[pAngle(i,j,c)] + pGline(i,j,c) * sin[pAngle(i,j,c)]] *
           [ vSOCP_cij(rp,k,i,j  )] ]
;

eSOCP_ExiLineQji(rpk(rp,k),i,j,c) $[le (i,j,c) and pEnableTransNet and pEnableSOCP]..
   vLineQ       (rp,k ,j,i,c) =e= pSBase * [
      - [    vSOCP_cii(rp,k,  j  )] * [pBline(i,j,c) + pBcline(i,j,c)/2]
      - [1/  pRatio   (     i,j,c)] *
           [ pGline   (     i,j,c)  * cos[pAngle(i,j,c)] + pBline(i,j,c) * sin[pAngle(i,j,c)]] *
           [ vSOCP_sij(rp,k,i,j  )]
      + [1/  pRatio   (     i,j,c)] *
           [ pBline   (     i,j,c)  * cos[pAngle(i,j,c)] - pGline(i,j,c) * sin[pAngle(i,j,c)]] *
           [ vSOCP_cij(rp,k,i,j  )] ]
;

* active and reactive power flow on candidates lines
eSOCP_CanLinePij1(rpk(rp,k),i,j,c) $[lc (i,j,c) and pEnableTransNet and pEnableSOCP]..
  vLineP        (rp,k ,i,j,c)  =g= pSBase * [
      + [   pGline    (     i,j,c)  * [vSOCP_cii(rp,k,i)] / sqr[pRatio(i,j,c)]]
      - [1/ pRatio    (     i,j,c)] *
           [pGline    (     i,j,c)  * cos[pAngle(i,j,c)] - pBline(i,j,c) * sin[pAngle(i,j,c)]] *
           [ vSOCP_cij(rp,k,i,j  )]
      - [1/ pRatio    (     i,j,c)] *
           [pBline    (     i,j,c)  * cos[pAngle(i,j,c)] + pGline(i,j,c) * sin[pAngle(i,j,c)]] *
           [-vSOCP_sij(rp,k,i,j  )] ]
      - pBigM_Flow * [1 - vLineInvest(i,j,c)]
;

eSOCP_CanLinePij2(rpk(rp,k),i,j,c) $[lc (i,j,c) and pEnableTransNet and pEnableSOCP]..
  vLineP        (rp,k ,i,j,c)  =l= pSBase * [
      + [   pGline    (     i,j,c)  * [vSOCP_cii(rp,k,i)] / sqr[pRatio(i,j,c)]]
      - [1/ pRatio    (     i,j,c)] *
           [pGline    (     i,j,c)  * cos[pAngle(i,j,c)] - pBline(i,j,c) * sin[pAngle(i,j,c)]] *
           [ vSOCP_cij(rp,k,i,j  )]
      - [1/ pRatio    (     i,j,c)] *
           [pBline    (     i,j,c)  * cos[pAngle(i,j,c)] + pGline(i,j,c) * sin[pAngle(i,j,c)]] *
           [-vSOCP_sij(rp,k,i,j  )] ]
      + pBigM_Flow * [1 - vLineInvest(i,j,c)]
;

eSOCP_CanLinePji1(rpk(rp,k),i,j,c) $[lc (i,j,c) and pEnableTransNet and pEnableSOCP]..
   vLineP       (rp,k ,j,i,c) =g= pSBase * [
      + [   pGline    (     i,j,c)  * [vSOCP_cii(rp,k,j)]]
      - [1/ pRatio    (     i,j,c)] *
           [pGline    (     i,j,c)  * cos[pAngle(i,j,c)] + pBline(i,j,c) * sin[pAngle(i,j,c)]] *
           [ vSOCP_cij(rp,k,i,j  )]
      - [1/ pRatio    (     i,j,c)] *
           [pBline    (     i,j,c)  * cos[pAngle(i,j,c)] - pGline(i,j,c) * sin[pAngle(i,j,c)]] *
           [ vSOCP_sij(rp,k,i,j  )] ]
      - pBigM_Flow * [1 - vLineInvest(i,j,c)]
;

eSOCP_CanLinePji2(rpk(rp,k),i,j,c) $[lc (i,j,c) and pEnableTransNet and pEnableSOCP]..
   vLineP       (rp,k ,j,i,c) =l= pSBase * [
      + [   pGline    (     i,j,c)  * [vSOCP_cii(rp,k,j)]]
      - [1/ pRatio    (     i,j,c)] *
           [pGline    (     i,j,c)  * cos[pAngle(i,j,c)] + pBline(i,j,c) * sin[pAngle(i,j,c)]] *
           [ vSOCP_cij(rp,k,i,j  )]
      - [1/ pRatio    (     i,j,c)] *
           [pBline    (     i,j,c)  * cos[pAngle(i,j,c)] - pGline(i,j,c) * sin[pAngle(i,j,c)]] *
           [ vSOCP_sij(rp,k,i,j  )] ]
      + pBigM_Flow * [1 - vLineInvest(i,j,c)]
;

eSOCP_CanLineQij1(rpk(rp,k),i,j,c) $[lc (i,j,c) and pEnableTransNet and pEnableSOCP]..
   vLineQ       (rp,k ,i,j,c)  =g= pSBase * [
      - [[   vSOCP_cii(rp,k,i    )] * [pBline(i,j,c) + pBcline(i,j,c)/2] / sqr[pRatio(i,j,c)]]
      - [1/  pRatio   (     i,j,c)] *
           [ pGline   (     i,j,c)  * cos[pAngle(i,j,c)] - pBline(i,j,c) * sin[pAngle(i,j,c)]] *
           [-vSOCP_sij(rp,k,i,j  )]
      + [1/  pRatio   (     i,j,c)] *
           [ pBline   (     i,j,c)  * cos[pAngle(i,j,c)] + pGline(i,j,c) * sin[pAngle(i,j,c)]] *
           [ vSOCP_cij(rp,k,i,j  )] ]
      - pBigM_Flow * [1 - vLineInvest(i,j,c)]
;

eSOCP_CanLineQij2(rpk(rp,k),i,j,c) $[lc (i,j,c) and pEnableTransNet and pEnableSOCP]..
   vLineQ       (rp,k ,i,j,c)  =l= pSBase * [
      - [[   vSOCP_cii(rp,k,i    )] * [pBline(i,j,c) + pBcline(i,j,c)/2] / sqr[pRatio(i,j,c)]]
      - [1/  pRatio   (     i,j,c)] *
           [ pGline   (     i,j,c)  * cos[pAngle(i,j,c)] - pBline(i,j,c) * sin[pAngle(i,j,c)]] *
           [-vSOCP_sij(rp,k,i,j  )]
      + [1/  pRatio   (     i,j,c)] *
           [ pBline   (     i,j,c)  * cos[pAngle(i,j,c)] + pGline(i,j,c) * sin[pAngle(i,j,c)]] *
           [ vSOCP_cij(rp,k,i,j  )] ]
      + pBigM_Flow * [1 - vLineInvest(i,j,c)]
;

eSOCP_CanLineQji1(rpk(rp,k),i,j,c) $[lc (i,j,c) and pEnableTransNet and pEnableSOCP]..
   vLineQ       (rp,k ,j,i,c) =g= pSBase * [
      - [    vSOCP_cii(rp,k,  j  )] * [pBline(i,j,c) + pBcline(i,j,c)/2]
      - [1/  pRatio   (     i,j,c)] *
           [ pGline   (     i,j,c)  * cos[pAngle(i,j,c)] + pBline(i,j,c) * sin[pAngle(i,j,c)]] *
           [ vSOCP_sij(rp,k,i,j  )]
      + [1/  pRatio   (     i,j,c)] *
           [ pBline   (     i,j,c)  * cos[pAngle(i,j,c)] - pGline(i,j,c) * sin[pAngle(i,j,c)]] *
           [ vSOCP_cij(rp,k,i,j  )] ]
      - pBigM_Flow * [1 - vLineInvest(i,j,c)]
;

eSOCP_CanLineQji2(rpk(rp,k),i,j,c) $[lc (i,j,c) and pEnableTransNet and pEnableSOCP]..
   vLineQ       (rp,k ,j,i,c) =l= pSBase * [
      - [    vSOCP_cii(rp,k,  j  )] * [pBline(i,j,c) + pBcline(i,j,c)/2]
      - [1/  pRatio   (     i,j,c)] *
           [ pGline   (     i,j,c)  * cos[pAngle(i,j,c)] + pBline(i,j,c) * sin[pAngle(i,j,c)]] *
           [ vSOCP_sij(rp,k,i,j  )]
      + [1/  pRatio   (     i,j,c)] *
           [ pBline   (     i,j,c)  * cos[pAngle(i,j,c)] - pGline(i,j,c) * sin[pAngle(i,j,c)]] *
           [ vSOCP_cij(rp,k,i,j  )] ]
      + pBigM_Flow * [1 - vLineInvest(i,j,c)]
;

* active and reactive power flow limit on candidates lines
eSOCP_LimCanLinePij1(rpk(rp,k),i,j,c) $[lc(i,j,c) and pEnableTransNet and pEnableSOCP]..vLineP(rp,k,i,j,c)/ pPmax(i,j,c) =g= -vLineInvest(i,j,c) ;
eSOCP_LimCanLinePij2(rpk(rp,k),i,j,c) $[lc(i,j,c) and pEnableTransNet and pEnableSOCP]..vLineP(rp,k,i,j,c)/ pPmax(i,j,c) =l=  vLineInvest(i,j,c) ;
eSOCP_LimCanLinePji1(rpk(rp,k),i,j,c) $[lc(i,j,c) and pEnableTransNet and pEnableSOCP]..vLineP(rp,k,j,i,c)/ pPmax(i,j,c) =g= -vLineInvest(i,j,c) ;
eSOCP_LimCanLinePji2(rpk(rp,k),i,j,c) $[lc(i,j,c) and pEnableTransNet and pEnableSOCP]..vLineP(rp,k,j,i,c)/ pPmax(i,j,c) =l=  vLineInvest(i,j,c) ;

eSOCP_LimCanLineQij1(rpk(rp,k),i,j,c) $[lc(i,j,c) and pEnableTransNet and pEnableSOCP]..vLineQ(rp,k,i,j,c)/ pQmax(i,j,c) =g= -vLineInvest(i,j,c) ;
eSOCP_LimCanLineQij2(rpk(rp,k),i,j,c) $[lc(i,j,c) and pEnableTransNet and pEnableSOCP]..vLineQ(rp,k,i,j,c)/ pQmax(i,j,c) =l=  vLineInvest(i,j,c) ;
eSOCP_LimCanLineQji1(rpk(rp,k),i,j,c) $[lc(i,j,c) and pEnableTransNet and pEnableSOCP]..vLineQ(rp,k,j,i,c)/ pQmax(i,j,c) =g= -vLineInvest(i,j,c) ;
eSOCP_LimCanLineQji2(rpk(rp,k),i,j,c) $[lc(i,j,c) and pEnableTransNet and pEnableSOCP]..vLineQ(rp,k,j,i,c)/ pQmax(i,j,c) =l=  vLineInvest(i,j,c) ;

* SOCP constraint for existing and candidate lines
eSOCP_ExiLine(rpk(rp,k),i,j) $[isLe(i,j) and pEnableTransNet and pEnableSOCP]..
   +  vSOCP_cij  (rp,k ,i,j) * vSOCP_cij(rp,k,i,j)
   +  vSOCP_sij  (rp,k ,i,j) * vSOCP_sij(rp,k,i,j)
  =l= vSOCP_cii  (rp,k ,i  ) * vSOCP_cii(rp,k,j  )
;

eSOCP_CanLine(rpk(rp,k),i,j) $[[1-sum[le(i,j,c)$[ord(c)=1],1]] and isLc(i,j) and pEnableTransNet and pEnableSOCP]..
   +  vSOCP_cij  (rp,k ,i,j) * vSOCP_cij(rp,k,i,j)
   +  vSOCP_sij  (rp,k ,i,j) * vSOCP_sij(rp,k,i,j)
  =l= vSOCP_cii  (rp,k ,i  ) * vSOCP_cii(rp,k,j  )
;

eSOCP_CanLine_cij (rpk(rp,k),i,j)$[   sum[le(i,j,c)$[ord(c)=1],1]  and isLc(i,j) and pEnableTransNet and pEnableSOCP].. vSOCP_cij(rp,k,i,j) =L=  pBigM_SOCP * vSOCP_IndicConnecNodes(i,j);
eSOCP_CanLine_sij1(rpk(rp,k),i,j)$[   sum[le(i,j,c)$[ord(c)=1],1]  and isLc(i,j) and pEnableTransNet and pEnableSOCP].. vSOCP_sij(rp,k,i,j) =L=  pBigM_SOCP * vSOCP_IndicConnecNodes(i,j);
eSOCP_CanLine_sij2(rpk(rp,k),i,j)$[   sum[le(i,j,c)$[ord(c)=1],1]  and isLc(i,j) and pEnableTransNet and pEnableSOCP].. vSOCP_sij(rp,k,i,j) =g= -pBigM_SOCP * vSOCP_IndicConnecNodes(i,j);

eSOCP_IndicConnecNodes1     (i,j)$[[  sum[le(i,j,c)$[ord(c)=1],1]] and isLc(i,j) and pEnableTransNet and pEnableSOCP].. vSOCP_IndicConnecNodes(i,j) =E= 1;
eSOCP_IndicConnecNodes2     (i,j)$[[1-sum[le(i,j,c)$[ord(c)=1],1]] and isLc(i,j) and pEnableTransNet and pEnableSOCP].. vSOCP_IndicConnecNodes(i,j) =E= [sum[c$[ord(c)=1], vLineInvest(i,j,c)]];

* Limits for SOCP variables of candidates lines
eSOCP_CanLineCijUpLim(rpk(rp,k),i,j) $[[1-sum[le(i,j,c)$[ord(c)=1],1]] and isLc(i,j)and pEnableTransNet and pEnableSOCP].. vSOCP_cij(rp,k,i,j) =l=         sqr[pBusMaxV(i)]  + pBigM_SOCP * [1-vSOCP_IndicConnecNodes(i,j)] ;
eSOCP_CanLineCijLoLim(rpk(rp,k),i,j) $[[1-sum[le(i,j,c)$[ord(c)=1],1]] and isLc(i,j)and pEnableTransNet and pEnableSOCP].. vSOCP_cij(rp,k,i,j) =g= max[0.1,sqr[pBusMinV(i)]] - pBigM_SOCP * [1-vSOCP_IndicConnecNodes(i,j)] ;
eSOCP_CanLineSijUpLim(rpk(rp,k),i,j) $[[1-sum[le(i,j,c)$[ord(c)=1],1]] and isLc(i,j)and pEnableTransNet and pEnableSOCP].. vSOCP_sij(rp,k,i,j) =l=         sqr[pBusMaxV(i)]  + pBigM_SOCP * [1-vSOCP_IndicConnecNodes(i,j)] ;
eSOCP_CanLineSijLoLim(rpk(rp,k),i,j) $[[1-sum[le(i,j,c)$[ord(c)=1],1]] and isLc(i,j)and pEnableTransNet and pEnableSOCP].. vSOCP_sij(rp,k,i,j) =g=        -sqr[pBusMaxV(i)]  - pBigM_SOCP * [1-vSOCP_IndicConnecNodes(i,j)] ;

* angles limits for existing and candidate lines
eSOCP_ExiLineAngDif1(rpk(rp,k),i,j) $[isLe(i,j) and pEnableTransNet and pEnableSOCP]..
   +   vSOCP_sij (rp,k ,i,j)
  =l= +vSOCP_cij (rp,k ,i,j)* tan(pMaxAngleDiff)
;

eSOCP_ExiLineAngDif2(rpk(rp,k),i,j) $[isLe(i,j) and pEnableTransNet and pEnableSOCP]..
   +   vSOCP_sij (rp,k ,i,j)
  =g= -vSOCP_cij (rp,k ,i,j)* tan(pMaxAngleDiff)
;

eSOCP_CanLineAngDif1(rpk(rp,k),i,j) $[[1-sum[le(i,j,c)$[ord(c)=1],1]] and isLc(i,j) and pEnableTransNet and pEnableSOCP]..
   +   vSOCP_sij (rp,k ,i,j)
  =l= +vSOCP_cij (rp,k ,i,j)* tan(pMaxAngleDiff)
   +   pBigM_SOCP * [1-vSOCP_IndicConnecNodes(i,j)]
;

eSOCP_CanLineAngDif2(rpk(rp,k),i,j) $[[1-sum[le(i,j,c)$[ord(c)=1],1]] and isLc(i,j) and pEnableTransNet and pEnableSOCP]..
   +   vSOCP_sij (rp,k ,i,j)
  =g= -vSOCP_cij (rp,k ,i,j)* tan(pMaxAngleDiff)
   -   pBigM_SOCP * [1-vSOCP_IndicConnecNodes(i,j)]
;

* It is disabled (even without investment) because it increases the time to solve
eSOCP_ExiLineSLimit(rpk(rp,k),i,j,c) $[[le(i,j,c) or  le(j,i,c)] and [pEnableTransNet and pEnableSOCP=9999]]..
   +  vLineP(    rp,k ,i,j,c) * vLineP(rp,k,i,j,c)
   +  vLineQ(    rp,k ,i,j,c) * vLineQ(rp,k,i,j,c)
  =l=[pPmax (          i,j,c) * pPmax (     i,j,c)
   +  pQmax (          i,j,c) * pQmax (     i,j,c)]**(1/2)
;

eSOCP_CanLineSLimit(rpk(rp,k),i,j,c) $[[lc(i,j,c) or  lc(j,i,c)] and [pEnableTransNet and pEnableSOCP=9999]]..
   +  vLineP(    rp,k ,i,j,c) * vLineP(rp,k,i,j,c)
   +  vLineQ(    rp,k ,i,j,c) * vLineQ(rp,k,i,j,c)
  =l=[pPmax (          i,j,c) * pPmax (     i,j,c)
   +  pQmax (          i,j,c) * pQmax (     i,j,c)]**(1/2)
   *  vLineInvest     (i,j,c)
;

$offFold

$onFold // Formulation Line Investment Constraints -----------------------------

eTranInves (i,j,c) $[lc(i,j,c) and pEnableTransNet and ord(c)>1]..
    vLineInvest(i,j,c) =l= vLineInvest(i,j,c-1) + sum[le(i,j,c-1),1];

$offFold

$onFold // Formulation CO2 Constraints -----------------------------------------

eCO2_Budget$[pEnableCO2]..
   + sum[(rpk(rp,k),t), pWeight_rp(rp)*pWeight_k(k) * pCO2Emis(t) * vGenP(rp,k,t)] + vCO2Undershoot - vCO2Overshoot
  =e=
   pCO2Budget
;

$offFold

$onFold // Formulation Ex-post Calculation of Voltage Angles in SOCP -----------

eDummyOf $[pEnableDummyModel]..
   vDummyOf =e= sum[(rp,k,isLine(i,j)), vDummySlackP(rp,k,i,j) + vDummySlackN(rp,k,i,j)] ;

eDummyAngDiff(rpk(rp,k),i,j) $[isLine(i,j) and pEnableDummyModel]..
   + vTheta      (rp,k,j  )
   - vTheta      (rp,k,i  )
   + vDummySlackP(rp,k,i,j)
   - vDummySlackN(rp,k,i,j)
  =e=
   + pDelVolAng  (rp,k,i,j) ;

$offFold

$endIf.FormulationsPower

$ifThenE.FormulationsH2 (%pEnableH2%=1) // Formulation H2 Sector Constraints ---

$onFold // Hydrogen Constraints (H2) -------------------------------------------

eH2_MaxCons(rpk(rp,k),h2g) $[pEnableH2].. vH2Consump(rp,k,h2g) =l=                pH2MaxCons(h2g) *              [vH2Invest (     h2g) + pH2ExisUnits(h2g)] ;
eH2_MaxProd(rpk(rp,k),h2g) $[pEnableH2].. vH2Prod   (rp,k,h2g) =l= pWeight_k(k) * pH2MaxCons(h2g) * pH2PE(h2g) * [vH2Invest (     h2g) + pH2ExisUnits(h2g)] ;
eH2_Convers(rpk(rp,k),h2g) $[pEnableH2].. vH2Prod   (rp,k,h2g) =e= pWeight_k(k) *                   pH2PE(h2g) *  vH2Consump(rp,k,h2g)                      ;

eH2_Balance(rpk(rp,k),h2i,h2sec) $[pEnableH2]..
   + sum[h2gh2i(h2g  ,h2i), vH2Prod(rp,k,h2g      )]
   + sum[h2line(h2j  ,h2i), vH2Flow(rp,k,h2j,h2i  )]
   - sum[h2line(h2i  ,h2j), vH2Flow(rp,k,h2i,h2j  )]
   +                        vH2NS  (rp,k,h2i,h2sec)
  =e=
   + pH2Demand (rp,k,h2i,h2sec)
;

$offFold

$endIf.FormulationsH2




*-------------------------------------------------------------------------------
*                                MODELS
*-------------------------------------------------------------------------------
$onFold // Model LEGO ----------------------------------------------------------

model LEGO / all / ;
LEGO.HoldFixed = 1 ; LEGO.optfile = 1; LEGO.TryLinear = 1 ;

$offFold

$onFold // Model mDummy --------------------------------------------------------

model mDummy   /eDummyOf  eDummyAngDiff/ ;
mDummy.holdfixed     = 1 ;

$offFold


*-------------------------------------------------------------------------------
*                            Options for Solvers
*-------------------------------------------------------------------------------
$onFold // Options for Solvers -------------------------------------------------
file     GOPT / gurobi.opt /               ;
put      GOPT / 'IIS 1'    / 'rins 1000' / 'nodefilestart 0.5' ;
putclose GOPT
;
file     COPT / cplex.opt  /                   ;
put      COPT / 'IIS 1'    / 'rinsheur 1000' / 'writemps LEGO-GAMS.mps' ;
putclose COPT
;

$offFold


*-------------------------------------------------------------------------------
*                   UPDATE OPTION BY BATCH FILE
*-------------------------------------------------------------------------------
$onFold // Update Option by Batch File -----------------------------------------


if(%BatchUpdate%=1,
   if(%RelaxedMIP%=0, pEnableRMIP=0);
   if(%RelaxedMIP%=1, pEnableRMIP=1);
   if(%EnableSOCP%=0, pEnableSOCP=0);
   if(%EnableSOCP%=1, pEnableSOCP=1);
);

pEnableSOCP $[pEnableTransNet=0] = 0 ;

$offFold


*-------------------------------------------------------------------------------
*                      Display Error Messages
*-------------------------------------------------------------------------------
$onFold // Check when using Zonal Prices ---------------------------------------
if (pEnableZP = 1,
    if (pEnableTransNet = 0 or pEnableSOCP = 1,
        abort "When using Zonal Pricing, pEnableTransNet has to be enabled and pEnableSOCP has to be disabled"
       )
   )
;
if (pEnableRMIP = 1 and pEnableChDisPower = 1,
        abort "Binary constraint (pEnableChDisPower) is not permitted for rMIP"       
   )
;

$offFold


*-------------------------------------------------------------------------------
*              Subsets activation and scaling parameters
*-------------------------------------------------------------------------------
$onFold // Subsets activation and scaling parameters ---------------------------

* assignment of import and export
* pMaxImport  (rp,k,i) = tImpExpData  (i, rp, k,'Import') * 1e-3;
* pMaxExport  (rp,k,i) = tImpExpData  (i, rp, k,'Export') * 1e-3;
* pPriceImpExp(rp,k,i) = tImpExpData  (i, rp, k,'Price' ) * 1e-3;


$ifThenE.ZonalPricing (%pEnablePower%=1)and(%pEnableZP%=1)
* assignment of NTCs
    pNTC(z,y)$[pEnablePower and pEnableZP              ] = tNTC(z,y,'Pmax')$[pEnableZP] * 1e-3  ;

* NTC subsets
    NTCe(z,y)$[pEnablePower and pEnableZP and pNTC(z,y)] = yes;
$endIf.ZonalPricing

* active representative periods
rpk(rp,k)$[pWeight_rp(rp) and pWeight_k(k)] = yes ;

*rpkimp(rp,k,i)    $[pWeight_rp(rp) and pWeight_k(k) and pMaxImport(rp,k,i)>0                         ] = yes ;
*rpkexp(rp,k,i)    $[pWeight_rp(rp) and pWeight_k(k) and pMaxExport(rp,k,i)>0                         ] = yes ;
*rpknimpexp(rp,k,i)$[pWeight_rp(rp) and pWeight_k(k) and pMaxExport(rp,k,i)=0 and pMaxImport(rp,k,i)=0] = yes ;



* assignment of thermal units (including biomass), storage units, and renewables
t    (g) $[ tThermalGen(g,'MaxProd'     )  and
           [tThermalGen(g,'ExisUnits'   )  or
            tThermalGen(g,'EnableInvest')]]   = yes ;
        
ror  (g) $[ tRunOfRiver(g,'MaxProd'     )  and
           [tRunOfRiver(g,'ExisUnits'   )  or
            tRunOfRiver(g,'EnableInvest')  *
            tRunOfRiver(g,'MaxInvest'   )]]   = yes ;

s    (g) $[ ror(g)                         or
           [tStorage    (g,'MaxProd'     ) and
            [tStorage   (g,'ExisUnits'   ) or
             tStorage   (g,'EnableInvest')  *
             tStorage   (g,'MaxInvest'   )]]] = yes ;

r    (g) $[ tRenewable (g,'MaxProd'     )  and
           [tRenewable (g,'ExisUnits'   )  or
            tRenewable (g,'EnableInvest')  *
            tRenewable (g,'MaxInvest'   )]]   = yes ;


v    (r) $[ tRenewable (r,'InertiaConst') ]   = yes ;
v    (s) $[[ tStorage   (s,'InertiaConst') ] or
           [ tRunOfRiver(s,'InertiaConst')]]  = yes ;
 
* assignment biomass only          
b    (g) $[ gtec(g,'Biomass') and 
            tThermalGen(g,'MaxProd'     )  and
           [tThermalGen(g,'ExisUnits'   )  or
            tThermalGen(g,'EnableInvest')] ]  = yes ;

* assignment solar only          
solar(g) $[ gtec(g,'Solar')   and 
            tRenewable(g,'MaxProd'     )  and
           [tRenewable(g,'ExisUnits'   )  or
            tRenewable(g,'EnableInvest')  *
            tRenewable(g,'MaxInvest'   )]]    = yes ;
            
* assignment wind only          
wind (g) $[ gtec(g,'Wind')    and 
            tRenewable(g,'MaxProd'     )  and
           [tRenewable(g,'ExisUnits'   )  or
            tRenewable(g,'EnableInvest')  *
            tRenewable(g,'MaxInvest'   )]]    = yes ;
            
* assignment hydro only          
hydro (g) $[ gtec(g,'Hydro')    and 
             tStorage (g,'MaxProd'     )  and
            [tStorage (g,'ExisUnits'   )  or
             tStorage (g,'EnableInvest')  *
             tStorage (g,'MaxInvest'   )]]    = yes ;

* assignment bess only          
bess  (g) $[ gtec(g,'BESS')    and 
             tStorage(g,'MaxProd'      )  and
            [tStorage(g,'ExisUnits'    )  or
             tStorage(g,'EnableInvest' )  *
             tStorage(g,'MaxInvest'    )]]    = yes ;

* assignment gas only 
gas   (g) $[ gtec(g,'Gas')   and 
             tThermalGen(g,'MaxProd'     )  and
            [tThermalGen(g,'ExisUnits'   )  or
             tThermalGen(g,'EnableInvest')] ] = yes ;
            
* assignment facts only
facts (g) $[ tFACTS     (g,'QMax'        )  and
            [tFACTS     (g,'ExisUnits'   )  or
             tFACTS     (g,'EnableInvest')] and
             pEnableSOCP           ]          = yes ;

ga    (g) $[t(g) or s(g) or r(g) or facts(g)] = yes ;

* assignemnt of generator to zone
loop[i,
    gz(g,z) $ [gi(g,i) and iz(i,z          )] = yes ;
    ]
;

$ifThenE.H2Assignments (%pEnableH2%=1) // Declaration H2 Sector Constraints --
* assignment of hydrogen units
h2g  (h2u)$[ tH2GenUnits(h2u,'MaxCons'     )     and
            [tH2GenUnits(h2u,'ExisUnits'   )     or
             tH2GenUnits(h2u,'EnableInvest')     *
             tH2GenUnits(h2u,'MaxInvest'   )]    and
             pEnableH2                       ] = yes ;

* future subsets for hydrogen fuel cell and storage units
h2f  (h2u) = no ;
h2s  (h2u) = no ;

* Hydrogen pipeline network
h2line(h2i,h2j) $[tH2Network(h2i,h2j,'InService') and pEnableH2] = yes ;
$endIf.H2Assignments


* network subsets
if(card(i) =1, pEnableTransNet = 0)                                               ;
la    (i,j,c) $[    tNetwork(i,j,c,'InService')              ] = yes              ;
lc    (i,j,c) $[    tNetwork(i,j,c,'pInvestCost') and la(i,j,c)] = yes              ;
le    (i,j,c) $[not tNetwork(i,j,c,'pInvestCost') and la(i,j,c)] = yes              ;
isLc  (i,j  )                                                  = sum[c,lc(i,j,c)] ;
isLe  (i,j  )                                                  = sum[c,le(i,j,c)] ;
isLine(i,j  )                                                  = sum[c,le(i,j,c)] ;
iact  (i    ) $[pEnableTransNet = 0 and is(i)]                 = yes              ;
iact  (i    ) $[pEnableTransNet = 1          ]                 = yes              ;
inws  (i    )                                                  = no              ;
iws   (i    ) $[iact(i) and not inws(i)]                       = yes              ;


* assigenment of lines with different zones
loop[z,
    lbz(i,j,c)$[la(i,j,c)     and [(iz(i,z)) xor (iz(j,z))]  ] = yes ;
    ]
;


* assigenment of lines with different zones
loop[g,
    za(z     )$[gz(g,z)  ] = yes ;
    ]
;

* scaling of parameters
pENSCost                     =                            pENSCost                   * 1e-3 ;
pLOLCost                     =                            pLOLCost                   * 1e-3 ;
pDSMShiftCost(rpk(rp,k),i  ) =                            tDSMshiftcost(rp,i,k)      * 1e-3 ;
pInflows     (rpk(rp,k),  s) =                            tInflows     (rp,s,k)      * 1e-3 ;
pResProfile  (rpk(rp,k),i,r) = sum[(gtec(r,tec),gi(r,i)), tVRESProfiles(rp,r,k)]            ;


* Thermal generation parameters
pEFOR             (t) = tThermalGen(t,'EFOR'        ) ;
pEnabInv          (t) = tThermalGen(t,'EnableInvest') ;
pInertiaConst     (t) = tThermalGen(t,'InertiaConst') ;
pMaxProd          (t) = tThermalGen(t,'MaxProd'     ) * 1e-3 * [1-pEFOR(t)] ;
pMinProd          (t) = tThermalGen(t,'MinProd'     ) * 1e-3 * [1-pEFOR(t)] ;
pRampUp           (t) = tThermalGen(t,'RampUp'      ) * 1e-3                ;
pRampDw           (t) = tThermalGen(t,'RampDw'      ) * 1e-3                ;
pMaxGenQ          (t) = tThermalGen(t,'Qmax'        ) * 1e-3 ;
pMinGenQ          (t) = tThermalGen(t,'Qmin'        ) * 1e-3 ;
pSlopeVarCost     (t) = (tThermalGen(t,'OMVarCost'   ) * 1e-3 +
                        tThermalGen(t,'FuelCost')) /  (tThermalGen(t,'Efficiency')) * 1e-3;
pInterVarCost     (t) = tThermalGen(t,'CommitConsumption') * 1e-6 * tThermalGen(t,'FuelCost') ;
pStartupCost      (t) = tThermalGen(t,'StartupConsumption' ) * 1e-6 * tThermalGen(t,'FuelCost') ;
pSlopeVarFuelCons (t) = tThermalGen(t,'Efficiency') * 1e-3 ;
pInterVarCons     (t) = tThermalGen(t,'CommitConsumption') * 1e-6 ;
pStartupCons      (t) = tThermalGen(t,'StartupConsumption' ) * 1e-6 ;
pInvestCost       (t) = tThermalGen(t,'InvestCost'  ) * 1e-3 *
                        pMaxProd   (t               ) ;
pFirmCapCoef      (t) = tThermalGen(t,'FirmCapCoef' ) ;
pCO2Emis          (t) = tThermalGen(t,'CO2Emis'     ) * 1e-3 ;
* For the linearization of the RoCoF, the UC variables must have a limit of 1
pExisUnits        (t) = min[1,tThermalGen(t,'ExisUnits')] ;
pMaxInvest        (t) $[pExisUnits(t)=1] = 0              ;
pMaxInvest        (t) $[pExisUnits(t)=0] = 1              ;

* Storage units parameters
pExisUnits   (s) =  [tStorage   (s,'ExisUnits'   )]$[not ror(s)]
                  + [tRunOfRiver(s,'ExisUnits'   )]$[    ror(s)];
pMaxInvest   (s) =  [tStorage   (s,'MaxInvest'   )]$[not ror(s)]
                  + [tRunOfRiver(s,'MaxInvest'   )]$[    ror(s)];
pMaxProd     (s) =  [tStorage   (s,'MaxProd'     )]$[not ror(s)] * 1e-3
                  + [tRunOfRiver(s,'MaxProd'     )]$[    ror(s)] * 1e-3;
pMinProd     (s) =  [tStorage   (s,'MinProd'     )]$[not ror(s)] * 1e-3
                  + [tRunOfRiver(s,'MinProd'     )]$[    ror(s)] * 1e-3;
pMaxCons     (s) =  [tStorage   (s,'MaxCons'     )]$[not ror(s)] * 1e-3
                  + [tRunOfRiver(s,'MaxCons'     )]$[    ror(s)] * 1e-3;
pOMVarCost   (s) =  [tStorage   (s,'OMVarCost'   )]$[not ror(s)] * 1e-3
                  + [tRunOfRiver(s,'OMVarCost'   )]$[    ror(s)] * 1e-3;
pMaxGenQ     (s) =  [tStorage   (s,'Qmax'        )]$[not ror(s)] * 1e-3
                  + [tRunOfRiver(s,'Qmax'        )]$[    ror(s)] * 1e-3;
pMinGenQ     (s) =  [tStorage   (s,'Qmin'        )]$[not ror(s)] * 1e-3
                  + [tRunOfRiver(s,'Qmin'        )]$[    ror(s)] * 1e-3;
pReplaceCost (s) =  [tStorage   (s,'ReplaceCost' )]$[not ror(s)] * 1e-3
                  + [tRunOfRiver(s,'ReplaceCost' )]$[    ror(s)] * 1e-3;
pInertiaConst(s) =  [tStorage   (s,'InertiaConst')]$[not ror(s)]
                  + [tRunOfRiver(s,'InertiaConst')]$[    ror(s)];
pDisEffic    (s) =  [tStorage   (s,'DisEffic'    )]$[not ror(s)]
                  + [tRunOfRiver(s,'DisEffic'    )]$[    ror(s)];
pChEffic     (s) =  [tStorage   (s,'ChEffic'     )]$[not ror(s)]
                  + [tRunOfRiver(s,'ChEffic'     )]$[    ror(s)];
pIsHydro     (s) =  [tStorage   (s,'IsHydro'     )]$[not ror(s)]
                  + [tRunOfRiver(s,'IsHydro'     )]$[    ror(s)];
pEnabInv     (s) =  [tStorage   (s,'EnableInvest')]$[not ror(s)]
                  + [tRunOfRiver(s,'EnableInvest')]$[    ror(s)];
pE2PRatio    (s) =  [tStorage   (s,'Ene2PowRatio')]$[not ror(s)]
                  + [tRunOfRiver(s,'Ene2PowRatio')]$[    ror(s)];
pShelfLife   (s) =  [tStorage   (s,'ShelfLife'   )]$[not ror(s)]
                  + [tRunOfRiver(s,'ShelfLife'   )]$[    ror(s)];
pCDSF_alpha  (s) =  [tStorage   (s,'CDSF_alpha'  )]$[not ror(s)]
                  + [tRunOfRiver(s,'CDSF_alpha'  )]$[    ror(s)];
pCDSF_beta   (s) =  [tStorage   (s,'CDSF_beta '  )]$[not ror(s)]
                  + [tRunOfRiver(s,'CDSF_beta '  )]$[    ror(s)];
pMinReserve  (s) =  [tStorage   (s,'MinReserve'  )]$[not ror(s)]
                  + [tRunOfRiver(s,'MinReserve'  )]$[    ror(s)];
pIniReserve  (s) = [[tStorage   (s,'IniReserve'  )]$[not ror(s)]
                  + [tRunOfRiver(s,'IniReserve'  )]$[    ror(s)]] *
                     pMaxProd   (s               )                *
                     pE2PRatio  (s               )              ;
pFirmCapCoef (s) =  [tStorage   (s,'FirmCapCoef' )]$[not ror(s)]
                  + [tRunOfRiver(s,'FirmCapCoef' )]$[    ror(s)];

pInvestCost  (s) =  [[tStorage   (s,'MaxProd'         )$[not ror(s)]] + [tRunOfRiver   (s,'MaxProd'         )$[    ror(s)]]] * 1e-3 *
                   [[[tStorage   (s,'InvestCostPerMW' )$[not ror(s)]] + [tRunOfRiver   (s,'InvestCostPerMW' )$[    ror(s)]]] * 1e-3 +
                    [[tStorage   (s,'InvestCostPerMWh')$[not ror(s)]] + [tRunOfRiver   (s,'InvestCostPerMWh')$[    ror(s)]]] * 1e-3 *
                      pE2PRatio  (s                   ) ]      ;

pDisEffic(s) $[pDisEffic(s) = 0] = 1 ; // if the efficiency of a storage unit is 0, it is changed to 1

cdsf      (s  ) $[pCDSF_alpha (s) and [not pIsHydro(s)] and pEnableCDSF] = yes ;

pCDSF_phi (s,a) $[ cdsf       (s)]= pCDSF_alpha (s  )*rPower[ord(a)     /card(a),pCDSF_beta(s)] ;
pCDSF_cost(s,a) $[ cdsf       (s)]=[pReplaceCost(s  )/pDisEffic (s    )]*card(a)*
                                   [pCDSF_phi   (s,a)-pCDSF_phi (s,a-1)] ;

* Renewable parameters
pExisUnits   (r) = tRenewable (r,'ExisUnits'   )        ;
pMaxInvest   (r) = tRenewable (r,'MaxInvest'   )        ;
pEnabInv     (r) = tRenewable (r,'EnableInvest')        ;
pInertiaConst(r) = tRenewable (r,'InertiaConst')        ;
pMaxProd     (r) = tRenewable (r,'MaxProd'     ) * 1e-3 ;
pMaxGenQ     (r) = tRenewable (r,'Qmax'        ) * 1e-3 ;
pMinGenQ     (r) = tRenewable (r,'Qmin'        ) * 1e-3 ;
pOMVarCost   (r) = tRenewable (r,'OMVarCost'   ) * 1e-3 ;
pInvestCost  (r) = tRenewable (r,'InvestCost'  ) * 1e-3 *
                   tRenewable (r,'MaxProd'     ) * 1e-3 ;
pFirmCapCoef (r) = tRenewable (r,'FirmCapCoef' )        ;

*Network parameters
pMaxAngleDiff = pMaxAngleDiff                * pi/180 ;
pSBase        = pSBase                       * 1e-3   ;
pRline    (la)= tNetwork (la,'pRline'           )         ;
pXline    (la)= tNetwork (la,'pXLine'           )          ;
pPmax     (la)= tNetwork (la,'pPmax'        ) * 1e-3   ;
pQmax     (la)= tNetwork (la,'pPmax'        ) * 1e-3   ; //assumption: it is equal to active limit
pBcline   (la)= tNetwork (la,'pBcline'          )          ;
pAngle    (la)= tNetwork (la,'pAngle'    ) * pi/180 ;
pRatio    (la)= tNetwork (la,'pRatio'    )          ;
pFixedCost(la)= tNetwork (la,'pInvestCost')          ;
pBline    (la)= -pXline  (la)/[sqr[pRline(la)]+sqr[pXline(la)]] ;
pGline    (la)=  pRline  (la)/[sqr[pRline(la)]+sqr[pXline(la)]] ;

*Bus parameters
pBusBaseV  (i) = tBusInfo(i,'pBusBaseV'   ) ;
pBusMaxV   (i) = tBusInfo(i,'pBusMaxV'    ) ;
pBusMinV   (i) = tBusInfo(i,'pBusMinV'    ) ;
pBusB      (i) = tBusInfo(i,'pBusB'         ) ;
pBusG      (i) = tBusInfo(i,'pBusG'         ) ;
pBus_pf    (i) = tBusInfo(i,'pBus_pf') ;
pRatioDemQP(i) = tan(arccos(pBus_pf(i))  ) ;

* FACTS for reactive power enery
pExisUnits (facts) = tFACTS  (facts,'ExisUnits'   )        ;
pEnabInv   (facts) = tFACTS  (facts,'EnableInvest')        ;
pMaxGenQ   (facts) = tFACTS  (facts,'Qmax'        ) * 1e-3 ;
pMinGenQ   (facts) = tFACTS  (facts,'Qmin'        ) * 1e-3 ;
pMaxInvest (facts) = tFACTS  (facts,'MaxInvest'   )        ;
pInvestCost(facts) = tFACTS  (facts,'InvestCost'  ) * 1e-3 *
                     pMaxGenQ(facts               )        ;

* active, reactive and peak demand
pDemandP(rpk(rp,k),i) = tDemand(rp,i,k)                  * 1e-3 ;
pDemandQ(rpk(rp,k),i) = tDemand(rp,i,k) * pRatioDemQP(i) * 1e-3 ;
pPeakDemand           = smax((rp,k)$rpk(rp,k),sum(i,pDemandP(rp,k,i)));

* zone PumpDemand, min production renewables
pPumpDemand(z) = tZones(z,'minHydroDemand')     * 1e3 ;
pMinSolar  (z) = tZones(z,'minSolar'      )     * 1e3 ;
pMinWind   (z) = tZones(z,'minWind'       )     * 1e3 ;
pMinBio    (z) = tZones(z,'minBiomass'    )     * 1e3 ;
pMinWater  (z) = tZones(z,'minRoRHydro'   )     * 1e3 ;
pMaxGas    (z) = tZones(z,'maxGas'        )     * 1e3 ;


display pPumpDemand,pMinSolar,pMinWind,pMinBio,pMinWater   ;

* demand-side management
pMaxUpDSM(rpk(rp,k),i,sec) = tDSMprofile  (k,rp,sec,'Up'       ) * tDemand(rp,i,k) * 1e-3 ;
pMaxDnDSM(rpk(rp,k),i,sec) = tDSMprofile  (k,rp,sec,'Down'     ) * tDemand(rp,i,k) * 1e-3 ;
pDSMShedCost (seg)         = tDSMshed     (seg,'ShedPenalty'   )                   * 1e-3 ;
pDSMShedRatio(seg)         = tDSMshed     (seg,'ShedPercentage')                          ;
pDSMDelayTime(sec,rp     ) = tDSMDelayTime(sec,rp              )                          ;

* DSM subset
dsm(rp,k,kk,sec) = no ;

loop[(rp,k,kk,sec)$[pEnableDSMPower],
    if [ord(k) <> ord(kk),
        if   [ord(k) - ord(kk) > 0,
                if[ord(k) - ord(kk) <= pDSMDelayTime(sec,rp),
                    dsm(rp,k,kk,sec) = yes];
        else
             if[ord(k) - ord(kk) <= -12,
                if[24 - (ord(kk) - ord(k)) <= pDSMDelayTime(sec,rp),
                    dsm(rp,k,kk,sec) = yes];
             else
                if[ord(kk) - ord(k) <= pDSMDelayTime(sec,rp),
                    dsm(rp,k,kk,sec) = yes];
                ]
             ]
       ]
    ]
;

$ifThenE.H2Parameters (%pEnableH2%=1) // Hydrogen parameters
pH2NSCost = pH2NSCost * 1e-3 ;

pH2Demand(rpk(rp,k),h2i,h2sec) = tH2Demand(h2sec,k,rp,h2i) * 1e-3 ;

pH2ExisUnits (h2g   ) = tH2GenUnits(h2g   ,'ExisUnits'   )        ;
pH2MaxInvest (h2g   ) = tH2GenUnits(h2g   ,'MaxInvest'   )        ;
pH2PE        (h2g   ) = tH2GenUnits(h2g   ,'H2Effic'     )        ;
pH2_pf       (h2g   ) = tH2GenUnits(h2g   ,'PowerFactor' )        ;
pH2MaxCons   (h2g   ) = tH2GenUnits(h2g   ,'MaxCons'     ) * 1e-3 ;
pH2OMPercent (h2g   ) = tH2GenUnits(h2g   ,'OMVarCost'   )        ;
pH2InvestCost(h2g   ) = tH2GenUnits(h2g   ,'InvestCost'  ) * 1e-3 *
                        tH2GenUnits(h2g   ,'MaxCons'     ) * 1e-3 ;

pH2OMVarCost (h2g   ) = pH2InvestCost(h2g) * pH2OMPercent (h2g)   ;

pH2Fmax      (h2line) = tH2Network (h2line,'Fmax'        ) * 1e-3 ;

pH2RatioQP   (h2g   ) = tan(arccos(pH2_pf(h2g))  ) ;
$endIf.H2Parameters

* update parameter to calculate regret
pRegretCalc $[%RegretCalc%=0 or  card(p)>card(k)] = 0 ;
pRegretCalc $[%RegretCalc%=1 and card(p)=card(k)] = 1 ;

* initializing parameter for SOCP ex-post calculations
pDelVolAng  (rpk(rp,k),i,j) $[isLine(i,j)] = 0;

* parameters for RoCoF
*pDeltaP(rpk(rp,k)) = pMinInertia * [pMaxRoCoF/pBaseFreq] ;
pDeltaP(rpk(rp,k)) = 0.3 ;

$offFold


*-------------------------------------------------------------------------------
*                  Bounds for variables
*-------------------------------------------------------------------------------
$onFold // Bounds for variables ------------------------------------------------

vGenP.up      (rpk(rp,k),t) =  pMaxProd  (t)                  *
                              [(pMaxInvest(t) * pEnabInv(t)) + pExisUnits(t)] ;
vGenP1.up     (rpk(rp,k),t) = [pMaxProd  (t) - pMinProd  (t)] *
                              [(pMaxInvest(t) * pEnabInv(t)) + pExisUnits(t)] ;
v2ndResUP.up  (rpk(rp,k),t) = [pMaxProd  (t) - pMinProd  (t)] *
                              [(pMaxInvest(t) * pEnabInv(t)) + pExisUnits(t)] ;
v2ndResDW.up  (rpk(rp,k),t) = [pMaxProd  (t) - pMinProd  (t)] *
                              [(pMaxInvest(t) * pEnabInv(t)) + pExisUnits(t)] ;

vGenQ.up      (rpk(rp,k),ga(g)) =  pMaxGenQ  (g)              ;
vGenQ.lo      (rpk(rp,k),ga(g)) =  pMinGenQ  (g)              ;

vGenP.up      (rpk(rp,k),s) =                  pMaxProd(s)  *[(pMaxInvest(s) * pEnabInv(s))+pExisUnits(s)];
v2ndResUP.up  (rpk(rp,k),s) =                  pMaxProd(s)  *[(pMaxInvest(s) * pEnabInv(s))+pExisUnits(s)];
vConsump.up   (rpk(rp,k),s) =                  pMaxCons(s)  *[(pMaxInvest(s) * pEnabInv(s))+pExisUnits(s)];
v2ndResDW.up  (rpk(rp,k),s) =  max[pMaxCons(s),pMaxProd(s)] *[(pMaxInvest(s) * pEnabInv(s))+pExisUnits(s)];

vGenP.up      (rpk(rp,k),r) =                  pMaxProd(r)  *[(pMaxInvest(r) * pEnabInv(r))+pExisUnits(r)] * sum[gi(r, i), pResProfile(rp,k ,i,r)];

vDSM_Up.up    (rpk(rp,k),i,sec)$[    pEnableDSMPower] =  pMaxUpDSM (rp,k,i,sec);
vDSM_Dn.up    (rpk(rp,k),i,sec)$[    pEnableDSMPower] =  pMaxDnDSM (rp,k,i,sec);
vDSM_Shed.up  (rpk(rp,k),i,seg)$[    pEnableDSMPower] =  pDSMShedRatio(seg) * pDemandP(rp,k,i);
vDSM_Up.fx    (rpk(rp,k),i,sec)$[not pEnableDSMPower] =  0;
vDSM_Dn.fx    (rpk(rp,k),i,sec)$[not pEnableDSMPower] =  0;
vDSM_Shed.fx  (rpk(rp,k),i,seg)$[not pEnableDSMPower] =  0;

vStIntraRes.up(rpk(rp,k),s) =  pE2PRatio (s) *
                               pMaxProd  (s) *[(pMaxInvest (s) * pEnabInv(s))+pExisUnits(s)] ;
vStIntraRes.lo(rpk(rp,k),s) =  pE2PRatio (s) * pMinReserve(s)*
                               pMaxProd  (s) *[(pMaxInvest (s) * pEnabInv(s))+pExisUnits(s)] ;

vCDSF_dis.up  (rpk(rp,k),s,a) $[cdsf(s)] = pMaxProd (s) *[(pMaxInvest (s) * pEnabInv(s))+pExisUnits(s)] ;
vCDSF_ch.up   (rpk(rp,k),s,a) $[cdsf(s)] = pMaxCons (s) *[(pMaxInvest (s) * pEnabInv(s))+pExisUnits(s)] ;
vCDSF_SoC.up  (rpk(rp,k),s,a) $[cdsf(s)] = pE2PRatio(s) *
                                           pMaxCons (s) *[(pMaxInvest (s) * pEnabInv(s))+pExisUnits(s)] ;

vSpillag.up   (rpk(rp,k),s) =  [ vStIntraRes.up(rp,k,s) -
                                 vStIntraRes.lo(rp,k,s)]$ [not ror(s)]
                               + pInflows      (rp,k,s) $ [    ror(s)];
vWaterSell.up (rpk(rp,k),s) =  vStIntraRes.up(rp,k,s) -
                               vStIntraRes.lo(rp,k,s) ;

vStInterRes.up(p,s) $[mod(ord(p),pMovWindow)=0] = pMaxProd(s)*[(pMaxInvest(s) * pEnabInv(s))+pExisUnits(s)]*pE2PRatio(s)                ;
vStInterRes.lo(p,s) $[mod(ord(p),pMovWindow)=0] = pMaxProd(s)*[(pMaxInvest(s) * pEnabInv(s))+pExisUnits(s)]*pE2PRatio(s)*pMinReserve(s) ;

$ifThenE.ZonalPricing (%pEnablePower%=1)and(%pEnableZP%=1)
    vImpZP.up   (rpk(rp,k),z,y) $[NTCe(z,y)] = pNTC(y,z) ;
    vExpZP.up   (rpk(rp,k),z,y) $[NTCe(z,y)] = pNTC(z,y) ;
$endIf.ZonalPricing

vLineP.up   (rpk(rp,k),i,j,c) $[le(i,j,c)]  =  pPmax (i,j,c) ;
vLineP.lo   (rpk(rp,k),i,j,c) $[le(i,j,c)]  = -pPmax (i,j,c) ;
vLineP.up   (rpk(rp,k),i,j,c) $[lc(i,j,c)]  =  pPmax (i,j,c) ;
vLineP.lo   (rpk(rp,k),i,j,c) $[lc(i,j,c)]  = -pPmax (i,j,c) ;

vLineQ.up   (rpk(rp,k),i,j,c) $[le(i,j,c)]  =  pQmax (i,j,c) ;
vLineQ.lo   (rpk(rp,k),i,j,c) $[le(i,j,c)]  = -pQmax (i,j,c) ;
vLineQ.up   (rpk(rp,k),j,i,c) $[le(i,j,c)]  =  pQmax (i,j,c) ;
vLineQ.lo   (rpk(rp,k),j,i,c) $[le(i,j,c)]  = -pQmax (i,j,c) ;

vSOCP_cii.up(rpk(rp,k),i    )              =         sqr[pBusMaxV(i)]  ;
vSOCP_cii.lo(rpk(rp,k),i    )              =         sqr[pBusMinV(i)]  ;
vSOCP_cij.up(rpk(rp,k),i,j  ) $[isLe(i,j)] =         sqr[pBusMaxV(i)]  ;
vSOCP_cij.lo(rpk(rp,k),i,j  ) $[isLe(i,j)] = max[0.1,sqr[pBusMinV(i)]] ; // This lower bound is always > 0
vSOCP_sij.up(rpk(rp,k),i,j  ) $[isLe(i,j)] =         sqr[pBusMaxV(i)]  ;
vSOCP_sij.lo(rpk(rp,k),i,j  ) $[isLe(i,j)] =        -sqr[pBusMaxV(i)]  ;

vAngle.up(rpk(rp,k),i,j,c   ) $[la(i,j,c)] =  pAngle(i,j,c);
vAngle.lo(rpk(rp,k),i,j,c   ) $[la(i,j,c)] = -pAngle(i,j,c);

vLineOverload.up(rpk(rp,k),i,j,c) $[isLe(i,j)or isLc(i,j)] = 1 - pMaxLineLoad ;

* slack bus voltage and angle
vSOCP_cii.fx(rpk(rp,k),is)$[    pEnableSOCP] = sqr[pSlackVoltage] ;
vTheta.up(rpk(rp, k),i) =  pMaxAngleDCOPF * pi / 180; // Add bounds for vTheta to make model tighter
vTheta.lo(rpk(rp, k),i) = -pMaxAngleDCOPF * pi / 180; // Add bounds for vTheta to make model tighter
vTheta.fx   (rpk(rp,k),is)$[not pEnableSOCP] = 0   ;

vPNS.up     (rpk(rp,k),     i ) =  pDemandP   (rp,k,i) ;
*vPNS.up    (rpk(rp,k),inws(i)) =  pMaxImport (rp,k,i) ;
vEPS.up     (rpk(rp,k),     i ) =  + inf               ;


vGenInvest.up(ga(g))                    = floor[pMaxInvest(g)] ;
vGenInvest.fx(ga(g)) $[not pEnabInv(g)] = 0                    ;

vLineInvest.fx(i,j,c)$[isLc(i,j) and le(i,j,c)]=0;

vRoCoF_AuxY.up(rpk(rp,k),tt,t  )$[pEnableRoCoF] =  1       ;
vRoCoF_AuxW.up(rpk(rp,k),vv,v,m)$[pEnableRoCoF] =  1       ;
vRoCoF_k.up   (rpk(rp,k),t     )$[pEnableRoCoF] =  1       ;
vRoCoF_k.up   (rpk(rp,k),v     )$[pEnableRoCoF] =  1       ;
vRoCoF_SG_M.up(rpk(rp,k)       )$[pEnableRoCoF] =  pUBLin  ;
vRoCoF_VI_M.up(rpk(rp,k)       )$[pEnableRoCoF] =  pUBLin  ;
vRoCoF_AuxZ.up(rpk(rp,k),t     )$[pEnableRoCoF] =  pUBLin  ;
vRoCoF_AuxV.up(rpk(rp,k),v,   m)$[pEnableRoCoF] =  pUBLin  ;

* last hour condition for storage
vStIntraRes.fx(rpk(rp,k),s) $[card(rp)=1 and ord(k)=card(k)] = pIniReserve(s) ;
vStInterRes.fx( p       ,s) $[card(rp)>1 and ord(p)=card(p)] = pIniReserve(s) ;

* spillage variable only for hydro units
vSpillag.fx(rpk(rp,k),s) $[pIsHydro(s)=0] = 0 ;

* bounds on variables for single node case
if(card(i)=1 or pEnableTransNet=0,
   vPNS.up     (rpk(rp,k),is)             = sum[j, pDemandP(rp,k,j)] ;
   vPNS.fx     (rpk(rp,k),i ) $[not is(i)]= 0                        ;
   vEPS.fx     (rpk(rp,k),i ) $[not is(i)]= 0                        ;
   
   if(pEnableDSMPower,
   vDSM_Up.up  (rpk(rp,k),is,sec)$[pEnableDSMPower] =  sum[j, pMaxUpDSM (rp,k,j,sec)];
   vDSM_Dn.up  (rpk(rp,k),is,sec)$[pEnableDSMPower] =  sum[j, pMaxDnDSM (rp,k,j,sec)];
   vDSM_Shed.up(rpk(rp,k),is,seg)$[pEnableDSMPower] =  sum[j, pDemandP  (rp,k,j)] * pDSMShedRatio(seg);
   vDSM_Up.fx  (rpk(rp,k),i ,sec)$[not is(i) ] =  0;
   vDSM_Dn.fx  (rpk(rp,k),i ,sec)$[not is(i) ] =  0;
   vDSM_Shed.fx(rpk(rp,k),i ,seg)$[not is(i) ] =  0;
   );
);

$ifThenE.BoundsH2 (%pEnableH2%=1) // Bounds for hydrogen variables
vH2NS.up    (rpk(rp,k),       h2i,h2sec)$[pEnableH2] =  pH2Demand   (rp,k,h2i,h2sec) ;
vH2Flow.up  (rpk(rp,k),h2line(h2i,h2j) )$[pEnableH2] =  pH2Fmax     (     h2i,h2j  ) ;
vH2Flow.lo  (rpk(rp,k),h2line(h2i,h2j) )$[pEnableH2] = -pH2Fmax     (     h2i,h2j  ) ;
vH2Invest.up(          h2g             )$[pEnableH2] =  pH2MaxInvest(     h2g      ) ;
$endIf.BoundsH2

$offFold


*-------------------------------------------------------------------------------
*                                    Solve
*-------------------------------------------------------------------------------
$onFold // Solve ---------------------------------------------------------------

* update info depending on UC.gdx file
$if not exist "./UC.gdx" pRegretCalc =0                       ;
$if not exist "./UC.gdx" pCommit(p,t)=0                       ;
$if not exist "./UC.gdx" pStLvMW(p,s)=0                       ;
$if     exist "./UC.gdx" execute_load 'UC.gdx' pCommit pStLvMW;

option solver = Gurobi;

* solve depending on options
if    (pEnableRMIP=1 and pRegretCalc=0,
   solve LEGO using RMIQCP minimizing vTotalVCost;

elseif(pEnableRMIP=1 and pRegretCalc=1),
   vCommit.fx    (rpk(rp,k),t) $[sum[hindex(p,rp,k), pCommit(p,t)]=1] = sum[hindex(p,rp,k), pCommit(p,t)];
   vStIntraRes.fx(rpk(rp,k),s) $[sum[hindex(p,rp,k), pStLvMW(p,s)]>0] = sum[hindex(p,rp,k), pStLvMW(p,s)];
   solve LEGO using RMIQCP minimizing vTotalVCost ;

elseif(pEnableRMIP=0 and pRegretCalc=0),
   solve LEGO using  MIQCP minimizing vTotalVCost ;

elseif(pEnableRMIP=0 and pRegretCalc=1),
   vCommit.fx    (rpk(rp,k),t) $[sum[hindex(p,rp,k), pCommit(p,t)]=1] = sum[hindex(p,rp,k), pCommit(p,t)];
   vStIntraRes.fx(rpk(rp,k),s) $[sum[hindex(p,rp,k), pStLvMW(p,s)]>0] = sum[hindex(p,rp,k), pStLvMW(p,s)];
   solve LEGO using  MIQCP minimizing vTotalVCost ;
);

if(pEnableSOCP,
   vTheta.fx (rpk(rp,k),is ) = 0 ;
   isLine(i,j) = sum[c,le(i,j,c)+lc(i,j,c)$vLineInvest.l(i,j,c)];
*   pDelVolAng(rpk(rp,k),i,j) $[isLine(i,j)] =  arctan2[vSOCP_sij.l(rp,k,i,j), vSOCP_cij.l(rp,k,i,j)+1e-6] ;
*   pEnableDummyModel = 1
*   solve mDummy min vDummyOf using lp;  // in order to find vTheta values
*  pEnableDummyModel = 0
);

*vGenInvest.fx(g) = vGenInvest.l(g);
*solve LEGO using  MIQCP minimizing vTotalVCost ;

*vCommit.fx(rp,k,g)=vCommit.l(rp,k,g);
*
*solve LEGO using  RMIQCP minimizing vTotalVCost ;


$offFold


**-------------------------------------------------------------------------------
**             Calculating ex post parameters for results
**-------------------------------------------------------------------------------
*$onFold // Summary -------------------------------------------------------------
*pSummary('----------- MODEL STATISTICS -----------    ') = eps ;
*pSummary('Obj Func Model                       [M€   ]') = LEGO.objVal  + eps ;
*pSummary('CAPEX (GEP, TEP, H2GEP)              [M€   ]') = + sum[ga(g    ), pInvestCost  (g    )* vGenInvest.l (g    )]
*                                                           + sum[lc(i,j,c), pFixedCost   (i,j,c)* vLineInvest.l(i,j,c)]
*$ifThenE.H2 (%pEnableH2%=1)
*                                                           + sum[h2u      , pH2InvestCost(h2u  )* vH2Invest.l  (h2u  )] $[pEnableH2]
*$endIf.H2
*                                                           + eps;
*pSummary('OPEX                                 [M€   ]') = vTotalVCost.l
*                                                           - sum[ga(g    ), pInvestCost  (g    )* vGenInvest.l (g    )]
*                                                           - sum[lc(i,j,c), pFixedCost   (i,j,c)* vLineInvest.l(i,j,c)]
*$ifThenE.H2 (%pEnableH2%=1)
*                                                           - sum[h2u      , pH2InvestCost(h2u  )* vH2Invest.l  (h2u  )] $[pEnableH2]
*$endIf.H2
*                                                           - eps;
*
*
*pSummary('CPU Time Model generation            [s    ]') = LEGO.resGen     + eps ;
*pSummary('CPU Time Model solution              [s    ]') = LEGO.resUsd     + eps ;
*pSummary('Number of variables                         ') = LEGO.numVar     + eps ;
*pSummary('Number of discrete variables                ') = LEGO.numDVar    + eps ;
*pSummary('Number of equations                         ') = LEGO.numEqu     + eps ;
*pSummary('Number of nonzero elements                  ') = LEGO.numNZ      + eps ;
*pSummary('Best possible solution for MIP              ') = LEGO.objest     + eps ;
*pSummary('Results for regret calculation              ') = pRegretCalc     + eps ;
*pSummary('Network Constraints 1->yes                  ') = pEnableTransNet + eps ;
*pSummary('1->SOCP , 0->DC                             ') = pEnableSOCP     + eps ;
*pSummary('1->RoCoF, 0->MinInert                       ') = pEnableRoCoF    + eps ;
*
*pSummary('SOCP Mean Error          ') $[not pEnableSOCP] = eps ;
*pSummary('SOCP Mean Error          ') $[    pEnableSOCP] = sum[(rpk(rp,k),i,j)$isLine(i,j),
*                                                               + vSOCP_cii.l(rp,k,i  ) * vSOCP_cii.l(rp,k,j  )
*                                                               - vSOCP_cij.l(rp,k,i,j) * vSOCP_cij.l(rp,k,i,j)
*                                                               - vSOCP_sij.l(rp,k,i,j) * vSOCP_sij.l(rp,k,i,j)] /
*                                                           sum[(rpk(rp,k),i,j)$isLine(i,j),
*                                                               + vSOCP_cii.l(rp,k,i  ) * vSOCP_cii.l(rp,k,j  )];
*
*
*pSummary('------------- POWER SYSTEM -------------    ') = eps ;
*pSummary('Total  system demand                 [GWh  ]') = sum[(rp,k),pWeight_rp(rp)*pWeight_k(k)*sum[j, pDemandP (rp,k,j)]] ;
*pSummary('Total  renewable + storage prod.     [GWh  ]') = sum[(rp,k),pWeight_rp(rp)*pWeight_k(k)*[+ sum[gi(r,j), vGenP.L(rp,k,r)]
*                                                                                                   + sum[gi(s,j), vGenP.L(rp,k,s)]]] + eps;
*
*pSummary('Total  renewable curtailment         [GWh  ]') = sum[(rp,k,gi(r,i)),pWeight_rp(rp)*pWeight_k(k)*[pResProfile(rp,k,i,r)*pMaxProd(r)*[vGenInvest.l(r)+pExisUnits(r)] - vGenP.l(rp,k,r)]] + eps ;
*pSummary('Total  thermal   production          [GWh  ]') = sum[(rp,k),pWeight_rp(rp)*pWeight_k(k)*[+ sum[gi(t,j), vGenP.L(rp,k,t)]]] + eps;
*pSummary('Actual green     production          [p.u. ]') = pSummary('Total  renewable + storage prod.     [GWh  ]') / pSummary('Total  system demand                 [GWh  ]') + eps;
*pSummary('Actual thermal   production          [p.u. ]') = pSummary('Total  thermal   production          [GWh  ]') / pSummary('Total  system demand                 [GWh  ]') + eps;
*
*pSummary('Total  renewable EAG + storage prod. [GWh  ]') = sum[(rp,k),pWeight_rp(rp)*pWeight_k(k)*[+ sum[gi(r,j), vGenP.L   (rp,k,r)]
*                                                                                                                   + sum[gi(s,j), vGenP.L   (rp,k,s)]
*                                                                                                                   + sum[gi(b,j), vGenP.L   (rp,k,b)]
*                                                                                                                   - sum[gi(s,j), vConsump.L(rp,k,s)]]] + eps;
*pSummary('Total  thermal   production EAG      [GWh  ]') = sum[(rp,k),pWeight_rp(rp)*pWeight_k(k)*[+ sum[gi(t,j), vGenP.L(rp,k,t)]
*                                                                                                   - sum[gi(b,j), vGenP.L(rp,k,b)]]] + eps;
*
*pSummary('Actual green     production EAG      [p.u. ]') = pSummary('Total  thermal   production EAG      [GWh  ]') / pSummary('Total  system demand                 [GWh  ]') + eps;
*pSummary('Actual thermal   production EAG      [p.u. ]') = pSummary('Total  thermal   production EAG      [GWh  ]') / pSummary('Total  system demand                 [GWh  ]') + eps;
*
*pSummary('Thermal            Investment        [GW   ]') = sum[t        , vGenInvest.l (t    ) * pMaxProd(t    )] + eps;
*pSummary('Renewable          Investment        [GW   ]') = sum[r        , vGenInvest.l (r    ) * pMaxProd(r    )] + eps;
*pSummary('Storage            Investment        [GW   ]') = sum[s        , vGenInvest.l (s    ) * pMaxProd(s    )] + eps;
*pSummary('Transmission lines Investment        [GW   ]') = sum[lc(i,j,c), vLineInvest.l(i,j,c) * pPmax   (i,j,c)] + eps;
*pSummary('Energy non-supplied                  [GWh  ]') = sum[(rp,k),pWeight_rp(rp)*pWeight_k(k)*sum[j          , vPNS.l (rp,k,j        )]] + eps;
*
*$ifThenE.H2 (%pEnableH2%=1)
*pSummary('----------- HYDROGEN SYSTEM ------------    ') = eps ;
*pSummary('H2 non-supplied                      [t    ]') = sum[(rp,k),pWeight_rp(rp)*pWeight_k(k)*sum[(h2i,h2sec), vH2NS.l(rp,k,h2i,h2sec)]] + eps;
*$endIf.H2
*pSummary('------------ CO2 EMISSIONS -------------    ') = eps ;
*pSummary('Budget CO2 emissions                 [MtCO2]') = pCO2Budget + eps ;
*pSummary('Actual CO2 emissions                 [MtCO2]') = sum[(rpk(rp,k),t), pWeight_rp(rp)*pWeight_k(k)*pCO2Emis(t)
*                                                               *[+(pStartupCons     (t)*vStartup.l(rp,k,t  ))
*                                                                 +(pInterVarCons    (t)*vCommit.l (rp,k,t  ))
*                                                                 +(pSlopeVarFuelCons(t)*vGenP.l   (rp,k,t  ))]]$[pEnableCO2]
*                                                           + eps;
*pSummary('CO2-target overshoot                 [MtCO2]') = vCO2Overshoot.l + eps;
*pSummary('--------------- POLICIES ---------------    ') = eps ;
*pSummary('Cost renewable quota                 [€/MWh]')$[not pEnableGreenNatBal]  = - eCleanProdLimThermal.m  * 1e3 + eps;
*pSummary('Cost renewable quota                 [€/MWh]')$[    pEnableGreenNatBal]  =   eCleanProdNatBal.m      * 1e3 + eps;
*pSummary('Payment firm capacity                [€/MW ]')$[    pMinFirmCap ]        =   eFirmCapCon.m           * 1e3 + eps;
*
*$offFold
*
*$onFold // Investment Results --------------------------------------------------
*
*pGenInvest (tec      ,'[MW]  ') = sum[gtec(ga(g),tec), pMaxProd(    g)*vGenInvest.l (    g)] * 1e3 + eps ;
*pGenInvest (tec      ,'[MVar]') = sum[gtec(ga(g),tec), pMaxGenQ(    g)*vGenInvest.l (    g)] * 1e3 + eps ;
*pTraInvest (lc(i,j,c),'[MW]'  ) =                      pPmax   (i,j,c)*vLineInvest.l(i,j,c)  * 1e3 + eps ;
*
*$offFold
*
*$onFold // Operating Dispatch Results ------------------------------------------
*
*pCommit  (p,t    ) = sum[hindex(p,rpk(rp,k)), vCommit.l (rp,k,t)    ]   + eps ;
*pGenP    (p,ga(g)) = sum[hindex(p,rpk(rp,k)), vGenP.l   (rp,k,g)*1e3]   + eps ;
*pGenQ    (p,ga(g)) = sum[hindex(p,rpk(rp,k)), vGenQ.l   (rp,k,g)*1e3]   + eps ;
*pChrP    (p,   s ) = sum[hindex(p,rpk(rp,k)), vConsump.l(rp,k,s)*1e3]   + eps ;
*pCurtP_k (rp,k,r ) = sum[   gi(r,i)         ,[pResProfile(rp,k,i,r)*pMaxProd(r)*[vGenInvest.l(r)+pExisUnits(r)] - vGenP.l(rp,k,r)]*1e3] + eps ;
*pCurtP_rp(rp,  r ) = sum[(k,gi(r,i))        ,[pResProfile(rp,k,i,r)*pMaxProd(r)*[vGenInvest.l(r)+pExisUnits(r)] - vGenP.l(rp,k,r)]*1e3] + eps ;
*pSpillag (p,ga(g)) = sum[hindex(p,rpk(rp,k)), vSpillag.l (rp,k,g)*1e3]  + eps ;
*
*pStIntra (k,s,rp) $[rpk(rp,k) and [card(rp)=1]                      ] = vStIntraRes.l(rp,k,s) / [pMaxProd(s)*[vGenInvest.l(s)+pExisUnits(s)]*pE2PRatio(s) + 1e-6] + eps ;
*pStIntra (k,s,rp) $[rpk(rp,k) and [card(rp)>1] and [not pIsHydro(s)]] = vStIntraRes.l(rp,k,s) / [pMaxProd(s)*[vGenInvest.l(s)+pExisUnits(s)]*pE2PRatio(s) + 1e-6] + eps ;
*
*pStLevel (p,s   ) $[[card(rp)=1]                      ] = sum[hindex   (p,rpk(rp,k)) , pStIntra(k,s,rp)]    ;
*pStLevel (p,s   ) $[[card(rp)>1] and [not pIsHydro(s)]] = sum[hindex   (p,rpk(rp,k)) , pStIntra(k,s,rp)]    ;
*pStLevel (p,s   ) $[[card(rp)>1] and [    pIsHydro(s)]] = vStInterRes.l(p   ,s) / [pMaxProd(s)*[vGenInvest.l(s)+pExisUnits(s)]*pE2PRatio(s) + 1e-6] + eps ;
*
*pStLvMW  (p,s   ) $[[card(rp)=1] and [    pIsHydro(s)] and [mod(ord(p),pMovWindow)=0]] = sum[hindex(p,rpk(rp,k)), vStIntraRes.l(rp,k,s)] + eps ;
*pStLvMW  (p,s   ) $[[card(rp)>1] and [    pIsHydro(s)] and [mod(ord(p),pMovWindow)=0]] =                          vStInterRes.l( p  ,s)  + eps ;
*
*pLineP(k,i,j,c,rp) $[rpk(rp,k) and la(i,j,c) and not pEnableTransNet                    ] =                               eps ;
*pLineP(k,i,j,c,rp) $[rpk(rp,k) and la(i,j,c) and     pEnableTransNet                    ] =  vLineP.l(rp,k,i,j,c) * 1e3 + eps ;
*pLineP(k,j,i,c,rp) $[rpk(rp,k) and la(i,j,c) and     pEnableTransNet and not pEnableSOCP] = -vLineP.l(rp,k,i,j,c) * 1e3 + eps ;
*pLineP(k,j,i,c,rp) $[rpk(rp,k) and la(i,j,c) and     pEnableTransNet and     pEnableSOCP] =  vLineP.l(rp,k,j,i,c) * 1e3 + eps ;
*pLineQ(k,i,j,c,rp) $[rpk(rp,k) and la(i,j,c) and not pEnableTransNet                    ] =                               eps ;
*pLineQ(k,i,j,c,rp) $[rpk(rp,k) and la(i,j,c) and     pEnableTransNet and not pEnableSOCP] =                               eps ;
*pLineQ(k,i,j,c,rp) $[rpk(rp,k) and la(i,j,c) and     pEnableTransNet and     pEnableSOCP] =  vLineQ.l(rp,k,i,j,c) * 1e3 + eps ;
*pLineQ(k,j,i,c,rp) $[rpk(rp,k) and la(i,j,c) and     pEnableTransNet and     pEnableSOCP] =  vLineQ.l(rp,k,j,i,c) * 1e3 + eps ;
*
*pLineP_Perc(k,i,j,c,rp) $[rpk(rp,k) and la(i,j,c) and not pEnableTransNet                    ] =                                      eps ;
*pLineP_Perc(k,i,j,c,rp) $[rpk(rp,k) and la(i,j,c) and     pEnableTransNet                    ] =  vLineP.l(rp,k,i,j,c)/pPmax(i,j,c) + eps ;
*pLineP_Perc(k,j,i,c,rp) $[rpk(rp,k) and la(i,j,c) and     pEnableTransNet and not pEnableSOCP] = -vLineP.l(rp,k,i,j,c)/pPmax(i,j,c) + eps ;
*
*
*pTecProd (i,tec         ,'Total [GWh]'  )                    =  sum[(rpk(rp,k),ga(g))$[gtec(g,tec) and gi(g,i)], pWeight_rp(rp)*pWeight_k(k)* vGenP.l    (rp,k,g    )               ] + eps ;
*pTecProd (i,'Sto_Charge','Total [GWh]'  )                    = -sum[(rpk(rp,k),   s )$[                gi(s,i)], pWeight_rp(rp)*pWeight_k(k)* vConsump.l (rp,k,s    )               ] + eps ;
*pTecProd (i,'ENS'       ,'Total [GWh]'  )                    =  sum[ rpk(rp,k)                                 , pWeight_rp(rp)*pWeight_k(k)* vPNS.l     (rp,k,i    )               ] + eps ;
*pTecProd (i,'P_Demand'  ,'Total [GWh]'  )                    = -sum[ rpk(rp,k)                                 , pWeight_rp(rp)*pWeight_k(k)* pDemandP   (rp,k,i    )               ] + eps ;
*pTecProd (i,'P_DSM_Shed','Total [GWh]'  ) $[pEnableDSMPower] =  sum[(rpk(rp,k),seg)                            , pWeight_rp(rp)*pWeight_k(k)* vDSM_Shed.l(rp,k,i,seg)               ] + eps ;
*pTecProd (i,'P_NetFlo'  ,'Total [GWh]'  )                    = -sum[(rpk(rp,k),j,c  )$[la (i,j,c)             ], pWeight_rp(rp)*pWeight_k(k)* vLineP.l   (rp,k,i,j,c)               ]
*                                                               +sum[(rpk(rp,k),j,c  )$[la (j,i,c)             ], pWeight_rp(rp)*pWeight_k(k)* vLineP.l   (rp,k,j,i,c)               ] + eps ;
*pTecProd (i,'P_NetFlo'  ,'Total [GWh]'  ) $[pEnableSOCP]     = -sum[(rpk(rp,k),j,c  )$[la (i,j,c)             ], pWeight_rp(rp)*pWeight_k(k)* vLineP.l   (rp,k,i,j,c)               ]
*                                                               -sum[(rpk(rp,k),j,c  )$[la (j,i,c)             ], pWeight_rp(rp)*pWeight_k(k)* vLineP.l   (rp,k,i,j,c)               ] + eps ;
*                                                             
*pTecProd (i,tec         ,'Total [GVarh]') $[pEnableSOCP]     =  sum[(rpk(rp,k),ga(g))$[gtec(g,tec) and gi(g,i)], pWeight_rp(rp)*pWeight_k(k)* vGenQ.l    (rp,k,g    )               ] + eps ;
*pTecProd (i,'QNS'       ,'Total [GVarh]') $[pEnableSOCP]     =  sum[ rpk(rp,k)                                 , pWeight_rp(rp)*pWeight_k(k)* vPNS.l     (rp,k,i    )*pRatioDemQP(i)] + eps ;
*pTecProd (i,'Q_Demand'  ,'Total [GVarh]') $[pEnableSOCP]     = -sum[ rpk(rp,k)                                 , pWeight_rp(rp)*pWeight_k(k)* pDemandQ   (rp,k,i    )*pEnableSOCP   ] + eps ;
*pTecProd (i,'Q_NetFlo'  ,'Total [GVarh]') $[pEnableSOCP]     = -sum[(rpk(rp,k),j,c  )$[la (i,j,c)             ], pWeight_rp(rp)*pWeight_k(k)* vLineQ.l   (rp,k,i,j,c)               ]
*                                                               -sum[(rpk(rp,k),j,c  )$[la (j,i,c)             ], pWeight_rp(rp)*pWeight_k(k)* vLineQ.l   (rp,k,i,j,c)               ] + eps ;
*pTecProd (i,'Q_DSM_Shed','Total [GVarh]') $[pEnableSOCP
*                                        and pEnableDSMPower] =  sum[(rpk(rp,k),seg)                            , pWeight_rp(rp)*pWeight_k(k)* vDSM_Shed.l(rp,k,i,seg)*pRatioDemQP(i)] + eps ;
*                                            
*pTecProdSum (tec         ,'Total [GWh]') =  sum[i                                                 , pTecProd (i,tec         ,'Total [GWh]')]                                      + eps ;
*pTecProdSum ('Sto_Charge','Total [GWh]') =  sum[i                                                 , pTecProd (i,'Sto_Charge','Total [GWh]')]                                      + eps ;
**pTecProdSum ('Imports'   ,'Total [GWh]') = -sum[(rpk(rp,k),i,j,c)$[lbz (i,j,c) and rpkexp(rp,k,j)], pWeight_rp(rp)*pWeight_k(k)* vLineP.l   (rp,k,i,j,c)]                         + eps ;
**pTecProdSum ('Exports'   ,'Total [GWh]') = -sum[(rpk(rp,k),i,j,c)$[lbz (i,j,c) and rpkimp(rp,k,j)], pWeight_rp(rp)*pWeight_k(k)* vLineP.l   (rp,k,i,j,c)]                         + eps ;
*
*display pTecProdSum;
*
*pTecProdHours(p   , tec         )        =  sum[(hindex(p,rpk(rp,k)),ga(g))$[gtec(g,tec) ]   , vGenP.l    (rp,k,g    )] + eps ;
*pTecProdHours(p   ,'Demand'     )        = -sum[(hindex(p,rpk(rp,k)),i)                      , pDemandP   (rp,k,i    )] + eps ;
*pTecProdHours(p   ,'Sto_Charge' )        = -sum[(hindex(p,rpk(rp,k)),s)                      , vConsump.l (rp,k,s    )] + eps ;
**pTecProdHours(p   ,'Imports'    )        = -sum[(hindex(p,rpk(rp,k)),i,j,c)$[rpkexp(rp,k,j)] , vLineP.l   (rp,k,i,j,c)] + eps ;
**pTecProdHours(p   ,'Exports'    )        = -sum[(hindex(p,rpk(rp,k)),i,j,c)$[rpkimp(rp,k,j)] , vLineP.l   (rp,k,i,j,c)] + eps ;
*
*display pTecProdHours;                     
*
*pTecProdRP   (rp,k, tec         )        =  sum[g$[gtec(g,tec)]          , vGenP.l    (rp,k,g    )] + eps ;
*pTecProdRP   (rp,k,'Demand'     )        = -sum[i                        , pDemandP   (rp,k,i    )] + eps ;
*pTecProdRP   (rp,k,'Sto_Charge' )        = -sum[s                        , vConsump.l (rp,k,s    )] + eps ;
**pTecProdRP   (rp,k,'Imports'    )        = -sum[(i,j,c)$[rpkexp(rp,k,j)] , vLineP.l   (rp,k,i,j,c)] + eps ;
**pTecProdRP   (rp,k,'Exports'    )        = -sum[(i,j,c)$[rpkimp(rp,k,j)] , vLineP.l   (rp,k,i,j,c)] + eps ;
*
*display pTecProdRP;
*
*pVoltage(k,i,rp)$[rpk(rp,k) and not pEnableTransNet                    ] = 1                         + eps ;
*pVoltage(k,i,rp)$[rpk(rp,k) and     pEnableTransNet and not pEnableSOCP] = 1                         + eps ;
*pVoltage(k,i,rp)$[rpk(rp,k) and     pEnableTransNet and     pEnableSOCP] = sqrt[vSOCP_cii.l(rp,k,i)] + eps ;
*
*pTheta  (k,i,rp)$[rpk(rp,k) and not pEnableTransNet] =                             eps ;
*pTheta  (k,i,rp)$[rpk(rp,k) and     pEnableTransNet] = vTheta.l(rp,k,i) * 180/pi + eps ;
*
*pBusRes (k,i,rp,'Qs','[Mvar]') $[rpk(rp,k) and pBusB(i)] = - [sqr[pVoltage(k,i,rp)] * pBusB(i) * pSBase] * 1e3 + eps ;
*pBusRes (k,i,rp,'Ps','[MW]'  ) $[rpk(rp,k) and pBusG(i)] = + [sqr[pVoltage(k,i,rp)] * pBusG(i) * pSBase] * 1e3 + eps ;
*
*pResulCDSF('obj. fun. cycle aging costs [M$]',s)$[not pIsHydro(s)] =
* sum[(rpk(rp,k),a), pWeight_rp(rp)*pWeight_k(k)*pCDSF_Cost(s,a)*vCDSF_dis.l(rp,k,s,a)] + eps
*;
*
*pCDSF_delta (p,s) = 0 ;
*pCDSF_delta (p,s)        $[pDisEffic(s)*pMaxProd(s)*[vGenInvest.l(s)+pExisUnits(s)]*pE2PRatio(s)]
*     = pGenP(p,s) * 1E-3 /[pDisEffic(s)*pMaxProd(s)*[vGenInvest.l(s)+pExisUnits(s)]*pE2PRatio(s)]
*     + pCDSF_delta (p-1,s)$[ord(p)>1]
*;
*pResulCDSF('Annual life loss from cycling [%]',s)$[not pIsHydro(s)] =
*  sum[p, pCDSF_alpha(s)*rPower[pCDSF_delta (p,s),pCDSF_beta(s)]] + eps;
*;
*
*pResulCDSF('Annual prorated cycle aging cost [M€]',s)$[not pIsHydro(s)] =
*  pReplaceCost(s) *[pMaxProd(s)*[vGenInvest.l(s)+pExisUnits(s)] * pE2PRatio(s)] *
*  pResulCDSF('Annual life loss from cycling [%]',s)
*;
*
*pResulCDSF('Battery life expectancy [year]',s)$[not pIsHydro(s) and pShelfLife(s)] =
** assuming proportional annual self life loss
*  1 /[1/pShelfLife(s) + pResulCDSF('Annual life loss from cycling [%]',s)]
*;
*
*$offFold
*
*$onFold // Economic Results Calculation ----------------------------------------
*
** electricity prices [€/MWh]
*pSRMC(p,i)$[not pEnableTransNet                    ] = sum[hindex(p,rpk(rp,k)), eSN_BalanceP.m  (rp,k,i) * 1e3 / [pWeight_rp(rp)*pWeight_k(k)]] + eps ;
*pSRMC(p,i)$[    pEnableTransNet and not pEnableSOCP] = sum[hindex(p,rpk(rp,k)), eDC_BalanceP.m  (rp,k,i) * 1e3 / [pWeight_rp(rp)*pWeight_k(k)]] + eps ;
*pSRMC(p,i)$[    pEnableTransNet and     pEnableSOCP] = sum[hindex(p,rpk(rp,k)), eSOCP_BalanceP.m(rp,k,i) * 1e3 / [pWeight_rp(rp)*pWeight_k(k)]] + eps ;
*
** electricity prices in rp and k [M€/GW]
*pMC(rp,k,i)$[not pEnableTransNet                                      ] = eSN_BalanceP.m  (rp,k,i) + eps ;
*pMC(rp,k,i)$[    pEnableTransNet and not pEnableSOCP and not pEnableZP] = eDC_BalanceP.m  (rp,k,i) + eps ;
*pMC(rp,k,i)$[    pEnableTransNet and     pEnableSOCP                  ] = eSOCP_BalanceP.m(rp,k,i) + eps ;
*
*$onFold // Ex-post calculation Zonal Pricing -----------------------------------
*
*$ifThenE.ZonalPricing (%pEnablePower%=1)and(%pEnableZP%=1)
** zonal prices in rp and k [€/MWh]
*pZonalPriceRP(rp,k,za(z))$[pEnableZP] =                          eZP_BalanceP.m  (rp,k,z) * 1e3 / [pWeight_rp(rp)*pWeight_k(k)]  + eps ;
** zonal prices per hour [€/MWhW]
*pZonalPrice  (p,za(z)   )$[pEnableZP] = sum[hindex(p,rpk(rp,k)), eZP_BalanceP.m  (rp,k,z) * 1e3 / [pWeight_rp(rp)*pWeight_k(k)]] + eps ;
*$endIf.ZonalPricing
*
*$offFold
*
** dual variables of inertia constraints
*pInertDual(k,rp) $[rpk(rp,k) and     pEnableRoCoF] = eRoCoF_SyEq1.m(rp,k) * 1e6 + eps ;
*pInertDual(k,rp) $[rpk(rp,k) and not pEnableRoCoF] = eMinInertia.m (rp,k) * 1e6 + eps ;
*
** new calculations for economic results (revenues, costs, profits, etc)
*pRevSpot (g)$[not pEnableTransNet                    ]  = + sum[(rpk(rp,k)), vGenP.l   (rp,k,g) * sum[i$gi(g,i), eSN_BalanceP.m(rp,k,i)]];
*pRevSpot (g)$[    pEnableTransNet and not pEnableSOCP]  = + sum[(rpk(rp,k)), vGenP.l   (rp,k,g) * sum[i$gi(g,i), eDC_BalanceP.m(rp,k,i)]];
*pRevSpot (g)$[    pEnableTransNet and     pEnableSOCP]  = + sum[(rpk(rp,k)), vGenP.l   (rp,k,g) * sum[i$gi(g,i), eSOCP_BalanceP.m(rp,k,i)]];
*
** only storage units can buy energy on spot market
*pCostSpot (s)$[not pEnableTransNet                    ] = + sum[(rpk(rp,k)), vConsump.l(rp,k,s) * sum[i$gi(s,i), eSN_BalanceP.m(rp,k,i)]];
*pCostSpot (s)$[    pEnableTransNet and not pEnableSOCP] = + sum[(rpk(rp,k)), vConsump.l(rp,k,s) * sum[i$gi(s,i), eDC_BalanceP.m(rp,k,i)]];
*pCostSpot (s)$[    pEnableTransNet and     pEnableSOCP] = + sum[(rpk(rp,k)), vConsump.l(rp,k,s) * sum[i$gi(s,i), eSOCP_BalanceP.m(rp,k,i)]];
*
*
*pRevReserve (g)   = + sum[(rpk(rp,k)), v2ndResUP.l(rp,k,g) * e2ReserveUp.m(rp,k)]
*                    + sum[(rpk(rp,k)), v2ndResDW.l(rp,k,g) * e2ReserveDw.m(rp,k)];
*
*pReserveCost(s)   = + sum[(rpk(rp,k)), pWeight_rp(rp)*pWeight_k(k)*pOMVarCost   (s)  *
*                                                    p2ndResUpCost     * v2ndResUP.l(rp,k,s)]
*                    + sum[(rpk(rp,k)), pWeight_rp(rp)*pWeight_k(k)*pOMVarCost   (s)  *
*                                                    p2ndResDwCost     * v2ndResDW.l(rp,k,s)] ;
*pReserveCost(t)   = + sum[(rpk(rp,k)), pWeight_rp(rp)*pWeight_k(k)*pSlopeVarCost(t) *
*                                                    p2ndResUpCost  * v2ndResUP.l(rp,k,t)]
*                    + sum[(rpk(rp,k)), pWeight_rp(rp)*pWeight_k(k)*pSlopeVarCost(t)  *
*                                                    p2ndResDwCost     * v2ndResDW.l(rp,k,t)] ;
*
** calculation of pRevRESQuota with hourly eCleanProdLimThermal constraint
*pRevRESQuota(t)$[pMinGreenProd and not pEnableGreenNatBal] = eCleanProdLimThermal.m  * sum[(rpk(rp,k)), pWeight_rp(rp)*pWeight_k(k) * vGenP.l(rp,k,t)] ;
*
** calculation of pRevRESQuota with national balance eCleanProdNatBal constraint
*pRevRESQuota(b)$[pMinGreenProd and pEnableGreenNatBal] =  eCleanProdNatBal.m  * sum[(rpk(rp,k)), pWeight_rp(rp)*pWeight_k(k) *  vGenP.l(rp,k,b)] ;
*pRevRESQuota(r)$[pMinGreenProd and pEnableGreenNatBal] =  eCleanProdNatBal.m  * sum[(rpk(rp,k)), pWeight_rp(rp)*pWeight_k(k) *  vGenP.l(rp,k,r)] ;
*pRevRESQuota(s)$[pMinGreenProd and pEnableGreenNatBal] =  eCleanProdNatBal.m  * sum[(rpk(rp,k)), pWeight_rp(rp)*pWeight_k(k) * [vGenP.l(rp,k,s) - vConsump.l(rp,k,s  )]] ;
*
*pFirmCapPay (g)$[pMinFirmCap] = eFirmCapCon.m * pFirmCapCoef(g)* pMaxProd(g)*[vGenInvest.l(g)+pExisUnits(g)];
*
*pInvCost(g)$ga(g) = pInvestCost(g)* vGenInvest.l(g);
*pOMCost       (s) = + sum[(rpk(rp,k)),             pWeight_rp(rp)*pWeight_k(k)*pOMVarCost(s  )*vGenP.l    (rp,k,s  )]
*                    + sum[(rpk(rp,k),a)$[cdsf(s)], pWeight_rp(rp)*pWeight_k(k)*pCDSF_Cost(s,a)*vCDSF_dis.l(rp,k,s,a)] ;
*pOMCost       (r) = + sum[(rpk(rp,k)), pWeight_rp(rp)*pWeight_k(k)*pOMVarCost   (r) * vGenP.l    (rp,k,r)] ;
*pOMCost       (t) = + sum[(rpk(rp,k)), pWeight_rp(rp)*pWeight_k(k)*pSlopeVarCost(t) * vGenP.l    (rp,k,t)]
*                    + sum[(rpk(rp,k)), pWeight_rp(rp)*pWeight_k(k)*pStartupCost (t) * vStartup.l (rp,k,t)]
*                    + sum[(rpk(rp,k)), pWeight_rp(rp)*pWeight_k(k)*pInterVarCost(t) * vCommit.l  (rp,k,t)] ;
*
*pTotalProfits (g) =   pRevSpot    (g)
*                    - pCostSpot   (g)
*                    + pRevReserve (g)
*                    - pReserveCost(g)
*                    + pFirmCapPay (g)
*                    + pRevRESQuota(g)
*                    - pInvCost    (g)
*                    - pOMCost     (g)
*;
*
*pEconomicResults('Spot market revenues    [M€]',g) =    pRevSpot     (g) + eps;
*pEconomicResults('Spot market costs       [M€]',g) =  - pCostSpot    (g) + eps;
*pEconomicResults('Reserve market revenues [M€]',g) =    pRevReserve  (g) + eps;
*pEconomicResults('Reserve market costs    [M€]',g) =  - pReserveCost (g) + eps;
*pEconomicResults('O&M costs               [M€]',g) =  - pOMCost      (g) + eps;
*pEconomicResults('Investment costs        [M€]',g) =  - pInvCost     (g) + eps;
*pEconomicResults('RES quota payments/cost [M€]',g) =    pRevRESQuota (g) + eps;
*pEconomicResults('Firm capacity payments  [M€]',g) =    pFirmCapPay  (g) + eps;
*pEconomicResults('Total profits           [M€]',g) =    pTotalProfits(g) + eps;
*
*$offFold
*
*$onFold // RoCoF results -------------------------------------------------------
*
*pRoCoF_k   (rp,k,t)$[pEnableRoCoF] = [vCommit.L(rp,k,t )*pMaxProd(t)/sum[tt,vCommit.L(rp,k,tt )* pMaxProd(tt)]
*                                                                  ]$[sum[tt,vCommit.L(rp,k,tt )* pMaxProd(tt)]>0];
*
*pRoCoF_k   (rp,k,v)$[pEnableRoCoF] = [vGenP.L(rp,k,v) / sum[gi(vv,i), pMaxProd(vv)*pResProfile(rp,k,i,vv)*[vGenInvest.L(vv)+pExisUnits(vv)] ]
*                                                     ]$[sum[gi(vv,i), pMaxProd(vv)*pResProfile(rp,k,i,vv)*[vGenInvest.L(vv)+pExisUnits(vv)] ]>0];
*
*pRoCoF_SG_M(rp,k  )$[pEnableRoCoF] = sum[t,2*pInertiaConst(t)*                 pRoCoF_k(rp,k,t)] ;
*pRoCoF_VI_M(rp,k  )$[pEnableRoCoF] = sum[v,2*pInertiaConst(v)* vGenInvest.L(v)*pRoCoF_k(rp,k,v)] ;
*
*pActualSysInertia(k,rp) $[pEnableRoCoF] =[[
*   +pRoCoF_SG_M(rp,k) * sum[t      ,pMaxProd(t)*vCommit.L       (rp,k,t)                                    ]
*   +pRoCoF_VI_M(rp,k) * sum[gi(v,i),pMaxProd(v)*vGenInvest.L    (     v)*pResProfile(rp,k,i,v)              ]
*   +pRoCoF_VI_M(rp,k) * sum[gi(v,i),pMaxProd(v)*                         pResProfile(rp,k,i,v)*pExisUnits(v)]
*                          ]
*                         /
*                          [
*   +sum[t      ,pMaxProd(t)*vCommit.L    (rp,k,t)                                    ]
*   +sum[gi(v,i),pMaxProd(v)*vGenInvest.L (     v)*pResProfile(rp,k,i,v)              ]
*   +sum[gi(v,i),pMaxProd(v)*                      pResProfile(rp,k,i,v)*pExisUnits(v)]
*                          ]]$[[
*   +sum[t      ,pMaxProd(t)*vCommit.L    (rp,k,t)                                    ]
*   +sum[gi(v,i),pMaxProd(v)*vGenInvest.L (     v)*pResProfile(rp,k,i,v)              ]
*   +sum[gi(v,i),pMaxProd(v)*                      pResProfile(rp,k,i,v)*pExisUnits(v)]
*                          ]>0]
*;
*
*$offFold
*
*$onFold // DSM results ---------------------------------------------------------
*
*pResultDSM(i,sec,'Up  ',rp,k) = vDSM_Up.l  (rp,k,i,sec) + eps;
*pResultDSM(i,sec,'Down',rp,k) = vDSM_Dn.l  (rp,k,i,sec) + eps;
*pResultDSM(i,seg,'Shed',rp,k) = vDSM_Shed.l(rp,k,i,seg) + eps;
*
*$offFold
*
*$onFold // H2 results ----------------------------------------------------------
*$ifThenE.H2 (%pEnableH2%=1)
*pH2price (h2sec,k,h2i,rp) $[rpk(rp,k) and pEnableH2] = eH2_Balance.m(rp,k,h2i,h2sec) * 1e3 / [pWeight_rp(rp)*pWeight_k(k)] + eps ;
*pH2Prod  (h2g  ,k,    rp) $[rpk(rp,k) and pEnableH2] = vH2Prod.l    (rp,k,h2g      ) * 1e3                                 + eps ;
*pH2Cons  (h2g  ,k,    rp) $[rpk(rp,k) and pEnableH2] = vH2Consump.l (rp,k,h2g      ) * 1e3                                 + eps ;
*pH2NS    (h2sec,k,h2i,rp) $[rpk(rp,k) and pEnableH2] = vH2NS.l      (rp,k,h2i,h2sec) * 1e3                                 + eps ;
*pH2Invest(h2g  ,'MW'    ) $[              pEnableH2] = vH2Invest.l  (h2g           ) * 1e3 *  pH2MaxCons(h2g)              + eps ;
*
*pSummary('Levelized cost of H2                 [€/kg ]') $[pEnableH2 and sum[(rpk(rp,k),h2u      )  , pWeight_rp(rp)*pWeight_k(k)                           * vH2Prod.l   (rp,k,h2u)]] =
*                                                                      [+ sum[           h2u         ,                             pH2InvestCost(h2u)        * vH2Invest.l (     h2u)]
*                                                                       + sum[           h2u         ,                             pH2OMVarCost (h2u)        * vH2Invest.l (     h2u)]
*                                                                       + sum[(rpk(rp,k),h2gi(h2g,i)),                             pMC          (    rp,k,i) * vH2Consump.l(rp,k,h2g)]] * 1e3
*                                                                       / sum[(rpk(rp,k),h2u        ), pWeight_rp(rp)*pWeight_k(k)                           * vH2Prod.l   (rp,k,h2u)]
*                                                                       + eps ;
*$endIf.H2
*
*option pSummary:2:0:1; display pSummary;
*
*$offFold
*
*
**-------------------------------------------------------------------------------
**                       Export results to Excel file
**-------------------------------------------------------------------------------
*$onFold // Export results to Excel file ----------------------------------------
*
** Create a results folder for execution if it doesn't exist yet
*$if not dexist "%scenarioFolder%/results" $call 'mkdir "%scenarioFolder%/results"'
*
** Copy .gms code & .lst file and delete old results
*$ifThen.OS not %system.fileSys% == UNIX
** Commands for Windows
*execute 'copy "LEGO.gms" "%scenarioFolder%/results/LEGO.gms"'
*execute 'copy "LEGO.lst" "%scenarioFolder%/results/LEGO.lst"'
*$if exist "%scenarioFolder%/results/results.xlsx" execute 'del "%scenarioFolder%\results\results.xlsx"'
*$elseIf.OS     %system.fileSys% == UNIX
** Commands for UNIX
*execute 'cp   "LEGO.gms" "%scenarioFolder%/results/LEGO.gms"'
*execute 'cp   "LEGO.lst" "%scenarioFolder%/results/LEGO.lst"'
*$if exist "%scenarioFolder%/results/results.xlsx" execute 'rm "%scenarioFolder%/results/results.xlsx"'
*
*$endIf.OS
*
** gdx with all information
*execute_unload   '%scenarioFolder%/results/LEGO_results.gdx';
*
*$onFold // Bare minimum output -------------------------------------------------
*if (pOutput=3,
*embeddedCode Connect:
*- GAMSReader:
*    symbols:
*      - name: pSummary
*      - name: pTecProd
*      - name: pGenInvest
*      - name: pTraInvest
*      - name: pH2Invest
*      - name: pTecProdSum
*- ExcelWriter:
*    file: %scenarioFolder%/results/results.xlsx
*    valueSubstitutions: {
*            "EPS": 0
*    }
*    symbols:
*      - name: pSummary
*        range: Summary!a1
*        columnDimension: 0
*      - name: pTecProd
*        range: TotalEn!a1
*        columnDimension: 2
*      - name: pGenInvest
*        range: GenInvest!a1
*        columnDimension: 1
*      - name: pTraInvest
*        range: TranInvest!a1
*        columnDimension: 1
*      - name: pH2Invest
*        range: H2Invest!a1
*        columnDimension: 1
*      - name: pTecProdSum
*        range: TotalEnSum!a1
*        columnDimension: 1
*endEmbeddedCode
*);
*$offFold
*
*$onFold // Reduced output ------------------------------------------------------
*if (pOutput=2,
*embeddedCode Connect:
*- GAMSReader:
*    symbols:
*      - name: pSummary
*      - name: pTecProd
*      - name: pGenInvest
*      - name: pTraInvest
*      - name: pH2Invest
*      - name: pTecProdSum
*      - name: pGenP
*      - name: pStIntra
*      - name: pStLevel
*      - name: pSRMC
*      - name: pLineP
*      - name: pEconomicResults
*      - name: pChrP
*      - name: pH2price
*      - name: pH2Prod
*      - name: pH2Cons
*      - name: pH2NS
*      - name: pTecProdhours
*      - name: pTecProdRP
*      - name: pCurtP_k
*      - name: pCurtP_rp
*      - name: pLineP_Perc
*      - name: pSpillag
*- ExcelWriter:
*    file: %scenarioFolder%/results/results.xlsx
*    valueSubstitutions: {
*            "EPS": 0
*    }
*    symbols:
*      - name: pSummary
*        range: Summary!a1
*        columnDimension: 0
*      - name: pTecProd
*        range: TotalEn!a1
*        columnDimension: 2
*      - name: pGenInvest
*        range: GenInvest!a1
*        columnDimension: 1
*      - name: pTraInvest
*        range: TranInvest!a1
*        columnDimension: 1
*      - name: pH2Invest
*        range: H2Invest!a1
*        columnDimension: 1
*      - name: pTecProdSum
*        range: TotalEnSum!a1
*        columnDimension: 1
*      - name: pGenP
*        range: GenP!a1
*        columnDimension: 1
*      - name: pStIntra
*        range: StIntra!a1
*        columnDimension: 2
*      - name: pStLevel
*        range: StLevel!a1
*        columnDimension: 1
*      - name: pSRMC
*        range: MC!a1
*        columnDimension: 1
*      - name: pLineP
*        range: pLineP!a1
*        columnDimension: 1
*      - name: pEconomicResults
*        range: Profits!a1
*        columnDimension: 1
*      - name: pChrP
*        range: Charge!a1
*        columnDimension: 1
*      - name: pH2price
*        range: H2price!a1
*        columnDimension: 2
*      - name: pH2Prod
*        range: H2Prod!a1
*        columnDimension: 1
*      - name: pH2Cons
*        range: H2Cons!a1
*        columnDimension: 1
*      - name: pH2NS
*        range: H2ns!a1
*        columnDimension: 2
*      - name: pTecProdhours
*        range: TotalEnhours!a1
*        columnDimension: 1
*      - name: pTecProdRP
*        range: TotalEnrp!a1
*        columnDimension: 1
*      - name: pCurtP_k
*        range: Curtail_k!a1
*        columnDimension: 1
*      - name: pCurtP_rp
*        range: Curtail_rp!a1
*        columnDimension: 1
*      - name: pLineP_Perc
*        range: LineP_Perc!a1
*        columnDimension: 1
*      - name: pSpillag
*        range: Spillag!a1
*        columnDimension: 1
*endEmbeddedCode
*);
*$offFold
*
*$onFold // All output ----------------------------------------------------------
*if (pOutput=1,
*embeddedCode Connect:
*- GAMSReader:
*    symbols:
*      - name: pSummary
*      - name: pTecProd
*      - name: pGenInvest
*      - name: pTraInvest
*      - name: pH2Invest
*      - name: pTecProdSum
*      - name: pGenP
*      - name: pStIntra
*      - name: pStLevel
*      - name: pSRMC
*      - name: pLineP
*      - name: pEconomicResults
*      - name: pChrP
*      - name: pH2price
*      - name: pH2Prod
*      - name: pH2Cons
*      - name: pH2NS
*      - name: pTecProdhours
*      - name: pTecProdRP
*      - name: pCurtP_k
*      - name: pCurtP_rp
*      - name: pLineP_Perc
*      - name: pSpillag
*      - name: pCommit
*      - name: pLineQ
*      - name: pVoltage
*      - name: pGenQ
*      - name: pTheta
*      - name: pBusRes
*      - name: pResulCDSF
*      - name: pInertDual
*      - name: pResultDSM
*      - name: pActualSysInertia
*- ExcelWriter:
*    file: %scenarioFolder%/results/results.xlsx
*    valueSubstitutions: {
*            "EPS": 0
*    }
*    symbols:
*      - name: pSummary
*        range: Summary!a1
*        columnDimension: 0
*      - name: pTecProd
*        range: TotalEn!a1
*        columnDimension: 2
*      - name: pGenInvest
*        range: GenInvest!a1
*        columnDimension: 1
*      - name: pTraInvest
*        range: TranInvest!a1
*        columnDimension: 1
*      - name: pH2Invest
*        range: H2Invest!a1
*        columnDimension: 1
*      - name: pTecProdSum
*        range: TotalEnSum!a1
*        columnDimension: 1
*      - name: pGenP
*        range: GenP!a1
*        columnDimension: 1
*      - name: pStIntra
*        range: StIntra!a1
*        columnDimension: 2
*      - name: pStLevel
*        range: StLevel!a1
*        columnDimension: 1
*      - name: pSRMC
*        range: MC!a1
*        columnDimension: 1
*      - name: pLineP
*        range: pLineP!a1
*        columnDimension: 1
*      - name: pEconomicResults
*        range: Profits!a1
*        columnDimension: 1
*      - name: pChrP
*        range: Charge!a1
*        columnDimension: 1
*      - name: pH2price
*        range: H2price!a1
*        columnDimension: 2
*      - name: pH2Prod
*        range: H2Prod!a1
*        columnDimension: 1
*      - name: pH2Cons
*        range: H2Cons!a1
*        columnDimension: 1
*      - name: pH2NS
*        range: H2ns!a1
*        columnDimension: 2
*      - name: pTecProdhours
*        range: TotalEnhours!a1
*        columnDimension: 1
*      - name: pTecProdRP
*        range: TotalEnrp!a1
*        columnDimension: 1
*      - name: pCurtP_k
*        range: Curtail_k!a1
*        columnDimension: 1
*      - name: pCurtP_rp
*        range: Curtail_rp!a1
*        columnDimension: 1
*      - name: pLineP_Perc
*        range: LineP_Perc!a1
*        columnDimension: 1
*      - name: pSpillag
*        range: Spillag!a1
*        columnDimension: 1
*      - name: pCommit
*        range: UC!a1
*        columnDimension: 1
*      - name: pLineQ
*        range: LineQ!a1
*        columnDimension: 1
*      - name: pVoltage
*        range: Volt!a1
*        columnDimension: 2
*      - name: pGenQ
*        range: GenQ!a1
*        columnDimension: 1
*      - name: pTheta
*        range: Angle!a1
*        columnDimension: 2
*      - name: pBusRes
*        range: BusRes!a1
*        columnDimension: 1
*      - name: pResulCDSF
*        range: CDSF!a1
*        columnDimension: 1
*      - name: pInertDual
*        range: InertDual!a1
*        columnDimension: 1
*      - name: pResultDSM
*        range: DSM!a1
*        columnDimension: 3
*      - name: pActualSysInertia
*        range: RoCoF!a1
*        columnDimension: 1
*endEmbeddedCode
*);
*$offFold
*
*$offFold
*
*
**-------------------------------------------------------------------------------
**                         Saving UC decisions
**-------------------------------------------------------------------------------
*$onFold // Saving UC decisions -------------------------------------------------
*if(%BatchUpdate%=1,
*   execute_unload '%scenarioFolder%/results/UC_tmp.gdx' pCommit pStLvMW;
*elseif(card(p)>card(k)),
*   execute_unload '%scenarioFolder%/results/UC.gdx' pCommit pStLvMW;
*);
*
*$OnListing
*
*$offFold
